<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>React 总结 | 随时奉陪</title><meta name="author" content="随时奉陪"><meta name="copyright" content="随时奉陪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="React 总结1. 基本概念React 是用于构建用户界面的 js 库, react 全家桶才是框架.全家桶包括  react : 核心库 react-dom : dom 操作 react-router : 路由管理 redux: 集中状态管理  全球范围内 react 使用范围最广,使用人数最多"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://metabo6.github.io/posts/4f68be61"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React 总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-24 10:44:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly/index.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-tags"></i><span> 仿 win10</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-folder-open"></i><span> 学习资料</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-anchor"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-place-of-worship"></i><span> 摸鱼大军</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/react.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">随时奉陪</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-tags"></i><span> 仿 win10</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-folder-open"></i><span> 学习资料</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-anchor"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-place-of-worship"></i><span> 摸鱼大军</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">React 总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-24T02:44:35.023Z" title="更新于 2022-11-24 10:44:35">2022-11-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="React 总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="React-总结"><a href="#React-总结" class="headerlink" title="React 总结"></a>React 总结</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>React 是用于构建用户界面的 js 库, react 全家桶才是框架.全家桶包括</p>
<ul>
<li>react : 核心库</li>
<li>react-dom : dom 操作</li>
<li>react-router : 路由管理</li>
<li>redux: 集中状态管理</li>
</ul>
<p>全球范围内 react 使用范围最广,使用人数最多,下载量也最大.附上三大框架下载趋势</p>
<p><a target="_blank" rel="noopener" href="https://www.npmtrends.com/angular-vs-react-vs-vue">react, vue, angular的下载趋势</a></p>
<p>react 特点: </p>
<ul>
<li>声明式: 只需要描述 UI 的样子,就跟写 html 一样. 用类似 html 的语法定义页面,通过数据驱动视图, 高效更新数据并渲染 DOM</li>
<li>组件化: 组件用于表示页面中的部分内容, 是 react 中最重要的内容,组合复用多个组件就能实现完整页面功能</li>
<li>使用广: 使用 react&#x2F;react-dom 可以开发 web 应用, 使用 react&#x2F;react-native 可以开发移动端应用,还可以使用 react&#x2F;react360 开发 VR 等.一次学习多次使用.众多大厂都在用</li>
</ul>
<h2 id="2-React-脚手架"><a href="#2-React-脚手架" class="headerlink" title="2. React 脚手架"></a>2. React 脚手架</h2><ol>
<li>官方开发的脚手架 <code>create-react-app</code>, 先安装脚手架工具包, 再使用脚手架命令来创建项目</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 下包 npm i -g create-react-app</span></span><br><span class="line"><span class="comment">// 2. 使用脚手架命令创建项目 create-react-app 项目名称</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 npm v5.2 版本新添加的命令来创建.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建命令 npx create-react-app 项目名称</span></span><br><span class="line"><span class="comment">// 2. npx create-react-app 是内置的固定命令,不能修改,项目名称可以自定义</span></span><br></pre></td></tr></table></figure>



<h2 id="3-项目目录"><a href="#3-项目目录" class="headerlink" title="3. 项目目录"></a>3. 项目目录</h2><p>使用脚手架创建项目后,会自动生成 src\public\node_modules 等目录,其中 src 就是进行项目开发的目录, src&#x2F;index 就是项目的入口文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 react 和 react-dom</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="comment">// 导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">// 创建元素 这是 react 18 版本更新后的新写法</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>( <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>) <span class="comment">// 渲染react元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元素 这是 react 18 版本前的写法</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="4-JSX-语法"><a href="#4-JSX-语法" class="headerlink" title="4. JSX 语法"></a>4. JSX 语法</h2><p> react 渲染是 React.createElement 格式. 由于这种格式太繁琐不优雅就出现了更好用的 jsx 语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement(&#x27;标签名&#x27;,&#123;标签上的属性1：值1&#125;,子元素1，子元素2)</span></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">id</span>:<span class="string">&#x27;box&#x27;</span>&#125;, <span class="string">&#x27;hello react&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>JSX 是 JavaScript XML 的缩写,可以在 JS 中书写 XML 结构, react 用它来创建 UI(HTML) 结构.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: jsx 不是标准的 js 语法,是 js 语法扩展.脚手架内置了 @babel/plugin-transform-react-jsx 包来解析该语法</span></span><br><span class="line"><span class="keyword">const</span> root = (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.root</span> &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"><span class="comment">// 该语法采用类似于 html 的语法,降低了学习门槛,使得页面结构更清晰直观.</span></span><br></pre></td></tr></table></figure>

<p>使用 JSX 语法有几点需要注意</p>
<ul>
<li>jsx 语法必须要有一个根节点</li>
<li>属性名如需使用 js 关键字需要使用代替语法. 如 类名 class 要使用 className 代替, label 中的 for 需使用 htmlFor 代替</li>
<li>单标签需闭合, 双标签也可简写成单标签+闭合标签</li>
<li>如有换行或多行 html 结构建议使用 ( ) 包裹</li>
<li>react 16.8 版本前必须先引入 react 才能使用 jsx 语法,原因是 jsx 本质是个语法糖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Login</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会被转换成如下所示, 其结果需要用到 react 所以必须导入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Login</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="literal">null</span>, <span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// react 脚手架升级版本后内部做了一些处理,所以不需要再导入 react 了</span></span><br></pre></td></tr></table></figure>

<h3 id="1-JSX-表达式"><a href="#1-JSX-表达式" class="headerlink" title="1.JSX 表达式"></a>1.JSX 表达式</h3><p>​	使用  <code>&#123; JS 表达式&#125;</code>  可以执行大括号内部的代码并输出结果. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 可以写属性值</span></span><br><span class="line"><span class="keyword">const</span> logo = <span class="string">&#x27;https://create-react-app.dev/img/logo.svg&#x27;</span></span><br><span class="line">&lt;img width=<span class="string">&quot;80&quot;</span> src=&#123;logo&#125; /&gt;</span><br><span class="line"><span class="comment">// 2. 可以写内容</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;小芳&#x27;</span></span><br><span class="line">&lt;div&gt;&#123;name&#125;&lt;/div&gt;</span><br><span class="line"><span class="comment">// 3. 可以写表达式,加减乘除和三元表达式等</span></span><br><span class="line"><span class="keyword">const</span> flag = <span class="number">0</span></span><br><span class="line">&lt;div&gt;&#123;flag ? <span class="string">&#x27;达成&#x27;</span> : <span class="string">&#x27;没有达成&#x27;</span>&#125;&lt;<span class="regexp">/div&gt;	&lt;div&gt;&#123; 1+2 &#125;&lt;/</span>div&gt; </span><br><span class="line"><span class="comment">// 4. 可以写注释</span></span><br><span class="line">&#123;<span class="comment">/* 所有子节点，都使用普通的 CSS 类名 */</span>&#125;</span><br><span class="line"><span class="comment">// 5. 不能写对象或 js 语句,包括 if/switch-case 等</span></span><br><span class="line"> &lt;p&gt;&#123;&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;&#125;&lt;<span class="regexp">/p&gt; 		 &lt;p&gt;&#123;var a =1 &#125;&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-JSX-列表渲染"><a href="#2-JSX-列表渲染" class="headerlink" title="2. JSX 列表渲染"></a>2. JSX 列表渲染</h3><p>可以在 JSX 中使用数组的 map 方法来生成列表结构, 可以重复生成相同的 HTML 结构</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> skills = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;html&#x27;</span> &#125;, </span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;css&#x27;</span> &#125;, </span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;js&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">      <span class="comment">// 在渲染的同时需加上 key</span></span><br><span class="line">    &#123;skills.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>技能&#123;item.id&#125;: &#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>在 React 内部渲染结构的同时,为了性能得到优化,必须同时加上 key 值, key 值不可以重复</p>
<h3 id="3-JSX-样式处理"><a href="#3-JSX-样式处理" class="headerlink" title="3. JSX 样式处理"></a>3. JSX 样式处理</h3><p>在 JSX 中写行内样式时,需使用双大括号包裹,外面的大括号表示里面的内容是一个表达式,里面的大括号表示是一个对象. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行内样式格式</span></span><br><span class="line">&lt;dom元素 style=&#123; &#123;css属性<span class="number">1</span>：值<span class="number">1</span>,css属性<span class="number">2</span>：值<span class="number">2</span>&#125; &#125;&gt;&lt;/dom元素&gt;</span><br><span class="line"><span class="comment">// 属性名不能有- , 需使用小驼峰格式命名 </span></span><br><span class="line"><span class="comment">// 属性值是字符串, 如果单位是 px 可以简写数值</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123;<span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27;, <span class="attr">width:</span> <span class="attr">200</span>, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">black</span>&#x27;&#125; &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">  我是黑底红字的h1</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="5-eslint-配置"><a href="#5-eslint-配置" class="headerlink" title="5. eslint 配置"></a>5. eslint 配置</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在 react 项目中配置 eslint ，并启用保存自动格式化功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 下包安装 eslint.  npm i eslint  -D</span></span><br><span class="line"><span class="comment">// 2. 在根路径运行命令 npx eslint --init,按照提示安装插件,会自动生成 eslint 配置文件</span></span><br><span class="line"><span class="comment">// 3. 设置 vscode 的自动保存格式化 设置=&gt; eslint =&gt; 勾选 always show status</span></span><br><span class="line"><span class="comment">// 4. 根路径下补充配置文件 .vscode/setting.json 内容如下</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;eslint.run&quot;</span>: <span class="string">&quot;onType&quot;</span>,</span><br><span class="line">  <span class="string">&quot;eslint.options&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;extensions&quot;</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.tsx&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eslint 并不能深入到 jsx 代码中完成格式化, 需要额外的工具  <code> prettier-now</code>, 该插件是 prettier 插件的分支, 允许更多配置项. 在 <code>.vscode/setting.json</code> 中配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;eslint.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onType&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;eslint.options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;extensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;.js&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.vue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.jsx&quot;</span><span class="punctuation">,</span> <span class="string">&quot;.tsx&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll.eslint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 编辑器设置 - 保存时做格式化</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 编辑器设置 - 默认采用prettier-now做格式化</span></span><br><span class="line">  <span class="comment">// 如果使用的是prettier，这的设置应该是 esbenp.prettier-vscode</span></span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span><span class="string">&quot;remimarsal.prettier-now&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 控制缩进</span></span><br><span class="line">  <span class="attr">&quot;prettier.useTabs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 缩进不使用tab，使用空格 </span></span><br><span class="line">  <span class="attr">&quot;prettier.tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment">// 缩进字节数 </span></span><br><span class="line">  <span class="comment">// 函数声明时小括号前后要加空格</span></span><br><span class="line">  <span class="comment">// 如果你使用prettier这一项是不能做选择的，导致和eslint默认配置的冲突</span></span><br><span class="line">  <span class="comment">// 可以在百度中搜到很多的记录： https://www.baidu.com/s?wd=prettier%20%E5%87%BD%E6%95%B0%E7%A9%BA%E6%A0%BC</span></span><br><span class="line">  <span class="attr">&quot;prettier.spaceBeforeFunctionParen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// react的jsx让&gt;与结束标签同行</span></span><br><span class="line">  <span class="attr">&quot;prettier.jsxBracketSameLine&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;prettier.bracketSpacing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 去掉数组内部前后的空格</span></span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// 不要给语句加;</span></span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 采用单引号</span></span><br><span class="line">  <span class="attr">&quot;prettier.trailingComma&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span> <span class="comment">// 不要尾随逗号,</span></span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span> <span class="comment">// 每行超过80列就换行</span></span><br><span class="line">  <span class="comment">// 在.js中，写div按下tab就可以自动补全，而不需要写&lt;div再补全</span></span><br><span class="line">  <span class="attr">&quot;emmet.includeLanguages&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;javascript&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javascriptreact&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>eslint 还可以使用插件帮助检查 Hooks 的使用是否符合规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 安装插件 npm install eslint-plugin-react-hooks -D</span><br><span class="line">// 配置规则: 在 eslint 配置文件规则中添加两条</span><br><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    // ...</span><br><span class="line">    &quot;react-hooks&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    // 检查 Hooks 的使用规则</span><br><span class="line">    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, </span><br><span class="line">    // 检查依赖项的声明</span><br><span class="line">    &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-大厂-UI-库"><a href="#6-大厂-UI-库" class="headerlink" title="6. 大厂 UI 库"></a>6. 大厂 UI 库</h2><ol>
<li>DIDI<ol>
<li>vue移动端 <a target="_blank" rel="noopener" href="https://didi.github.io/cube-ui/#/zh-CN">Cube UI</a></li>
</ol>
</li>
<li>JD<ol>
<li>vue移动端: <a target="_blank" rel="noopener" href="https://nutui.jd.com/#/index">NUTUI</a></li>
</ol>
</li>
<li>饿了么<ol>
<li>vuePC端 <a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">elementUI</a></li>
</ol>
</li>
<li>蚂蚁<ol>
<li>react PC端<a target="_blank" rel="noopener" href="https://ant.design/docs/react/introduce-cn">antdesign</a></li>
<li>vue PC端 <a target="_blank" rel="noopener" href="https://antdv.com/docs/vue/introduce-cn/">vue</a></li>
</ol>
</li>
<li>字节<ol>
<li>react PC端 <a target="_blank" rel="noopener" href="https://arco.design/react/docs/start">arco</a></li>
<li>vue3 PC端<a target="_blank" rel="noopener" href="https://arco.design/vue/docs/start">arco</a></li>
</ol>
</li>
</ol>
<hr>
<h2 id="7-react-组件"><a href="#7-react-组件" class="headerlink" title="7. react 组件"></a>7. react 组件</h2><p>组件就是对特定功能的封装,主要用来对 UI 进行拆分.其特点是可复用，独立，可组合.</p>
<p>可以分类为以下几种</p>
<ul>
<li>基础组件: 指 <code>input</code> , <code>button</code> 等这种基础的标签组件,以及 UI 库封装过的通用 UI 组件</li>
<li>业务组件: 由基础组件组合成的业务抽象化 UI , 如包含了某公司所有部门信息的下拉框</li>
<li>区块组件: 由基础组件和业务组件组合而成的 UI 块</li>
<li>页面组件: 展示给用户的最终页面,一般一个页面组件对应一个路由规则</li>
</ul>
<p>在 React  中组件主要分为两类: 函数式组件和类组件,  **使用组件 **可以使用单双标签包裹组件对象</p>
<h3 id="1-函数式组件"><a href="#1-函数式组件" class="headerlink" title="1. 函数式组件"></a>1. 函数式组件</h3><p>函数式组件即使用 JS 中的函数所创建的组件,一般是一个单独的 JS 文件 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数式组件 函数名首字符必须大写, react 据此区分组件和普通的 html 且必须有返回值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Com1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>第一个函数式组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Com1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-类组件"><a href="#2-类组件" class="headerlink" title="2. 类组件"></a>2. 类组件</h3><p>类组件即使用 JS ES6 语法中的 <code>class</code> 所创建的组件,使用比较繁琐</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类组件类组件首字母也必须大写 extends 是关键字,用来实现类的继承.</span></span><br><span class="line"><span class="comment">// 类组件应该继承 React.Component 父类从而使用父类中的属性和方法</span></span><br><span class="line"><span class="comment">// 类组件必须提供 render 方法, render 方法必须有返回值且在组件创建时会执行一次</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Com2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>第一个类组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Com2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-组件状态"><a href="#3-组件状态" class="headerlink" title="3.组件状态"></a>3.组件状态</h3><p>状态(state) 是用来描述失误在某一时刻的数据,例如 18岁时的身高,8月18日的电费等,在 react 中表示组件的私有数据. 其特点就是<strong>状态能被修改</strong>,修改后视图也会变化,其作用有两点</p>
<ul>
<li>保存数据. 如要循环生成一份歌曲列表，要提前准备好歌曲数据</li>
<li>为后续更新视图打下基础。如果用户操作了状态内容，视图会自动更新（由react库决定的）</li>
</ul>
<p>组件分为有状态组件和无状态组件. 在 react 16.8 版本中引入了 <strong>Hooks</strong>,从而函数式组件也能定义状态了</p>
<ul>
<li>有状态组件：能定义state的组件。类组件就是有状态组件。</li>
<li>无状态组件：不能定义state的组件。函数组件又叫做 无状态组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 类组件中有两种方式定义状态,较方便和常用的就是第一种</span></span><br><span class="line">  <span class="comment">// 方式1 state 定义状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">list</span>: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;明天会更好&quot;</span> &#125;,&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;难忘今宵&quot;</span> &#125;],</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 方式2 构造函数定义状态</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>() <span class="comment">// 在构造函数内部使用this，必须提前调用super</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">list</span>: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;明天会更好&quot;</span> &#125;,&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;难忘今宵&quot;</span> &#125;],</span><br><span class="line">      <span class="attr">isLoading</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 视图中使用 state 定义的数据, 通过 this.state 来使用</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>歌单-&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.state.list.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.isLoading ? &quot;正在加载&quot; : &quot;加载完成&quot;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-状态更新"><a href="#4-状态更新" class="headerlink" title="4. 状态更新"></a>4. 状态更新</h3><p>类组件中通过 setState 方法来修改 state 数据,修改后 state 变化, 视图会自动更新</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 通过 setState 方法修改</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>++ &#125;)</span><br><span class="line"><span class="comment">// 注意: react 核心理念就是状态不可改变, 而是创建新的状态数据去覆盖原有的数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> = <span class="number">100</span> <span class="comment">// 无效设置,会报错</span></span><br></pre></td></tr></table></figure>

<p>setState 方法其特点是调用之后，并不会立即去修改 state 的值，也不会立即去更新 dom , 而是会放在更新队列里, 等待多次调用完毕后统一触发一次 render() ,此时表现的像是 <strong>异步执行</strong> 一样.</p>
<p>使用不当会造成死循环,如在 componentDidUpdate，render 中调用 setState() 会导致死循环</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line">  hClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">n</span>: <span class="number">100</span>&#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">n</span>) <span class="comment">// 会打印 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;span&#x27;</span>).<span class="property">innerHTML</span>) <span class="comment">// 会打印 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.hClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span&quot;</span>&gt;</span> &#123;this.state.n&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState 方法不仅可以是一个对象, 还可以是一个回调函数, 其作用是当 setState 生效（ state 更新，页面 ui 更新）之后，会调用该回调函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">上一状态</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> 新状态</span><br><span class="line">&#125;[,回调函数])</span><br><span class="line"><span class="comment">// 更推荐语法: 传入一个回调函数,参数就是上一次 setState 结果 适用于需要调用多次 setState</span></span><br><span class="line">state = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(preState,<span class="number">222</span>)  <span class="comment">// 1  先打印 111 再打印 222</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: preState.<span class="property">count</span> + <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>,<span class="number">111</span>) <span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 在状态更新（页面完成重新渲染）后立即执行某个操作 就会用到完整语法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">	<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">100</span> &#125;),</span><br><span class="line">	<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 此处页面更新后触发,可以获取到更新后的数据</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这个回调函数会在状态更新后立即执行&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 101</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h2 id="8-事件绑定"><a href="#8-事件绑定" class="headerlink" title="8. 事件绑定"></a>8. 事件绑定</h2><p>React 中用驼峰命名法定义事件名,如 onMouseEnter、onFocus、 onClick … </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式 &lt;元素 事件名1=&#123; 事件处理函数1 &#125; 事件名2=&#123; 事件处理函数2 &#125;  &gt;&lt;/元素&gt;</span></span><br><span class="line"><span class="comment">// 在类组件中定义方法, 通过 this.方法名来访问,也可以直接写箭头函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mouseEnter事件&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(&#x27;click事件&#x27;)&#125;</span></span><br><span class="line"><span class="language-xml">        onMouseEnter=&#123;this.fn&#125; &gt;</span></span><br><span class="line"><span class="language-xml">        能处理鼠标进入或者点击事件</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-事件对象"><a href="#9-事件对象" class="headerlink" title="9. 事件对象"></a>9. 事件对象</h2><p>React 中通过事件处理函数的形参来获取事件对象</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的 e 就表示事件对象</span></span><br><span class="line"><span class="title function_">handleClick</span>(e)=&gt; &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;单击事件触发了&#x27;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123;console.log(&#x27;按钮点击了&#x27;, e)&#125;&#125;&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com/&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  	)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-this-指向"><a href="#10-this-指向" class="headerlink" title="10. this 指向"></a>10. this 指向</h2><p>在函数式组件中不存在 this 指向问题,而只在类组件中存在着 this 指向问题</p>
<ul>
<li>在 render 函数中 this 指向的是当前的 react 组件.</li>
<li>在自定义的方法中 this 原本指向 window, 由于 react 在 class 内部默认开启 JS 严格模式,故此处的 this 会指向 undefined</li>
</ul>
<p>想解决 this 指向问题有三种方式,第一种最方便常用</p>
<ul>
<li><ol>
<li>使用 class 的实例方法,即实例方法使用箭头函数</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处的 this 指向外部作用域, 即组件对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>使用 bind 修改 this 指向</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 页面渲染后绑定了 this ,此处的 this 指向该组件对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 组件创建 this 指向的是该组件</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>在外层补充箭头函数</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 此处的 this 指向外层作用域的 this , 其需要额外包裹箭头函数,结构不美观</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.handleClick()&#125;&#125;&gt;点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-获取表单元素的值"><a href="#11-获取表单元素的值" class="headerlink" title="11. 获取表单元素的值"></a>11. 获取表单元素的值</h2><p>在 react 中有两种方法获取表单元素的值</p>
<ul>
<li>直接找到表单元素进行 dom 操作,此方法称之为 <strong>非受控组件</strong></li>
<li>将表单元素的值与 state 进行绑定, 将用户的修改同步到 state 中,称之为 <strong>受控组件</strong></li>
</ul>
<h3 id="1-非受控组件-ref"><a href="#1-非受控组件-ref" class="headerlink" title="1. 非受控组件-ref"></a>1. 非受控组件-ref</h3><p>借助于 ref 获取 DOM 元素，使用原生 DOM 的方式来获取表单元素的值,使用不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1. 导入方法 import &#123; createRef &#125; from &#x27;react&#x27;</span><br><span class="line">// 2. 创建方法并引用 const refDom = createRef()</span><br><span class="line">// 3. 绑定给表单元素的 ref 属性. &lt;input ref=&#123; refDom &#125;/&gt;</span><br><span class="line">// 4. 通过 refDom.current.value 来获取值. console.log(refDom.current.value)</span><br></pre></td></tr></table></figure>

<h3 id="2-受控组件"><a href="#2-受控组件" class="headerlink" title="2. 受控组件"></a>2. 受控组件</h3><p>正常情况下，表单元素 input 可任意输入内容，可以理解为 input 自己维护它的状态（value）</p>
<p>在 state 中定义状态并绑定给表单元素的 value 值, 同时绑定 onChange 事件修改状态值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用受控组件处理表单元素，状态的值就是表单元素的值.操作表单元素的值，只操作对应的状态即可</span></span><br><span class="line"><span class="comment">// 1. 定义状态并绑定给表单元素</span></span><br><span class="line"> state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">msg</span>: e.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>  &#123;/* 2. 表单元素绑定事件 */&#125;</span></span><br><span class="line"><span class="language-xml">          	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.msg&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          	<span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 不同类型的表单元素进行受控处理时的格式是不同的. 多表单元素还可以优化</span></span><br><span class="line"><span class="comment">// 1. 文本框、文本域、下拉框：value属性 + onChange事件</span></span><br><span class="line"><span class="comment">// 2. 复选框和单选按钮: checked属性 + onChange事件</span></span><br><span class="line">  handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, type, value, checked&#125; = e.<span class="property">target</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, type, value, checked)</span><br><span class="line">    <span class="comment">// 此处判断表单元素的类型,同时表单元素需要设置 name 属性为绑定的状态属性名</span></span><br><span class="line">    value = type === <span class="string">&#x27;checkbox&#x27;</span> ? checked : value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; [name]: value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">username</span>&#125; onChange=&#123;<span class="variable language_">this</span>.<span class="property">handleChange</span>&#125;/&gt;</span><br></pre></td></tr></table></figure>



<h2 id="12-组件通讯"><a href="#12-组件通讯" class="headerlink" title="12. 组件通讯"></a>12. 组件通讯</h2><p>实际开发中,组件是一个单独的 JS 文件，其状态是私有的,只能在内部使用。想共享某些数据就需要有组件通讯</p>
<p>一般有三种方式:  父子组件之间	兄弟组件之间	跨组件层级</p>
<h3 id="1-父子通讯"><a href="#1-父子通讯" class="headerlink" title="1. 父子通讯"></a>1. 父子通讯</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中传递数据 =&gt;  &lt;子组件 自定义属性1=&#123;值1&#125; 自定义属性2=&#123;值2&#125; .... /&gt;</span></span><br><span class="line"><span class="comment">// 子组件接收数据： 函数式组件需要通过形参来获取 类组件需要通过 this.props 来获取</span></span><br><span class="line"><span class="keyword">function</span> 子组件(props) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;从父组件中传入的自定义属性被收集在对象:&#x27;</span>, props)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> 子组件 <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;从父组件中传入的自定义属性被收集在对象:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">&#125;, </span><br><span class="line"><span class="comment">// props 的特点: 可以传递任意数据, 传递的数据是只读的, 即单向数据流,无法直接修改</span></span><br><span class="line"><span class="comment">// 单向数据流是指 父向子传值的流向是单向的 父组件传递的数据更新时子组件会自动接收到最新数据</span></span><br><span class="line"><span class="comment">// props 中还有 children 属性, 表示该组件的子节点, 即该组件所包裹的内容</span></span><br><span class="line"><span class="comment">// 只要包裹了内容, props 就有该属性</span></span><br><span class="line"><span class="comment">// 例如: </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span>&gt;</span>我是子节点<span class="tag">&lt;/<span class="name">Hello</span>&gt;</span></span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">children</span>) <span class="comment">// 我是子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子传父: 利用父组件提供的回调函数来传递要修改的数据,回调函数的形参接收要修改的数据</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="attr">state</span>: &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;</span><br><span class="line">	<span class="comment">// 自定义函数, 当做值传递给子组件,并通过形参接收子组件要修改的数据</span></span><br><span class="line">    fn = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收到子组件数据&#x27;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            	子组件：<span class="tag">&lt;<span class="name">Child</span> <span class="attr">f</span>=<span class="string">&#123;this.fn&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件调用父组件传过来的函数,并传入要修改的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用父组件传入的props，并传入参数</span></span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fn</span>(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我，给父组件传递数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-兄弟组件通讯"><a href="#2-兄弟组件通讯" class="headerlink" title="2. 兄弟组件通讯"></a>2. 兄弟组件通讯</h3><p>使用<strong>状态提升</strong>, 实现兄弟组件之间的组件通讯</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将共享状态提升到最近的公共父组件中,由父组件管理状态,要通讯的子组件只需要接收状态即可</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Son1</span> <span class="keyword">from</span> <span class="string">&#x27;./Son1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Son2</span> <span class="keyword">from</span> <span class="string">&#x27;./Son2&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 状态提升到父组件 </span></span><br><span class="line">  state = &#123; <span class="attr">msg</span>: <span class="string">&#x27;jack&#x27;</span>&#125;</span><br><span class="line"> <span class="comment">// 提供方法修改状态 Son1 修改 Son2 的数据</span></span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; msg &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son1</span> <span class="attr">say</span>=<span class="string">&#123;this.changeMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 2. 把状态给子组件显示 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son2</span> <span class="attr">msg</span>=<span class="string">&#123;this.state.msg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  say = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">say</span>(<span class="string">&#x27;rose&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是 Son1 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.say&#125;</span>&gt;</span>说<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是 Son2 组件-&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-跨组件通讯"><a href="#3-跨组件通讯" class="headerlink" title="3. 跨组件通讯"></a>3. 跨组件通讯</h3><p>使用 <strong><code>Context</code></strong> 实现跨级组件通讯, 主要分为三个步骤</p>
<ul>
<li><ol>
<li>导入并调用 createContext 方法，从结果中解构出 Provider, Consumer 组件</li>
</ol>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以单独建立 context.js 文件 也可以直接在组件内部创建并导出 Consumer 组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Consumer</span>, <span class="title class_">Provider</span> &#125;</span><br><span class="line"><span class="comment">// 使用 Provider 包裹根组件, 并通过 value 传递数据</span></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">num:</span> <span class="attr">this.state.num</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Parent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Uncle</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 在任意后代组件中，使用导出的 Consumer 组件包裹整个组件, 并通过形参接收</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Consumer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  	&#123;（data） =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">      	// 这里的形参data 就会自动接收Provider中传入的数据</span></span><br><span class="line"><span class="language-xml">      	return <span class="tag">&lt;<span class="name">组件的内容</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    	&#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>使用 <strong>Provider</strong> 组件<strong>包裹根组件</strong>，并通过 <strong>value</strong> 属性提供要共享的数据</li>
</ol>
</li>
<li><ol start="3">
<li>在任意后代组件中，使用导出的 Consumer 组件包裹整个组件,形参接收数据</li>
</ol>
</li>
</ul>
<h2 id="13-传值-props-校验"><a href="#13-传值-props-校验" class="headerlink" title="13. 传值 props 校验"></a>13. 传值 props 校验</h2><p>对于组件来说，props 是外部传入的，无法保证组件使用者传入什么格式的数据.</p>
<p>如果传入的数据格式不对，可能会导致组件内部报错。<strong>组件的使用者不能很明确的知道错误的原因。</strong>故可以通过 props 校验来约定 prpos 的格式和数据类型,不满足条件就报错,增加组件健壮性</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入组件 这个包在使用脚手架创建项目时就自带了，无须额外安装</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="comment">// 2. 定义方法约定类型</span></span><br><span class="line">组件名.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="comment">// 约定类型, 如果类型不对，则报出明确错误，便于分析错误原因</span></span><br><span class="line">    <span class="comment">// 常见类型如 array、bool、func、number、object、string</span></span><br><span class="line">    属性名: <span class="title class_">PropTypes</span>.<span class="property">array</span> <span class="comment">// 约束类型</span></span><br><span class="line">	<span class="comment">// 必填项：isRequired</span></span><br><span class="line">    属性名: <span class="title class_">PropTypes</span>.<span class="property">array</span>.<span class="property">isRequired</span></span><br><span class="line">    <span class="comment">// 特定结构的对象：shape( &#123; &#125; )</span></span><br><span class="line">    属性名: <span class="title class_">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">        <span class="attr">fontSize</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以设置 props 默认值,在未传入 props 时生效,</span></span><br><span class="line">组件名.<span class="property">defaultProps</span> = &#123; <span class="attr">pageSize</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="comment">// 也可以使用解构赋值设置默认值</span></span><br><span class="line"><span class="keyword">const</span> &#123; pageSize = <span class="number">10</span>&#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">&lt;div&gt; 此处展示props的默认值：&#123;props.<span class="property">pageSize</span>&#125; &lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="14-组件生命周期"><a href="#14-组件生命周期" class="headerlink" title="14. 组件生命周期"></a>14. 组件生命周期</h2><blockquote>
<p>只有类组件才有生命周期</p>
</blockquote>
<p>组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程</p>
<p>意义：组件的生命周期有助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因</p>
<p>在生命周期的不同阶段，会<strong>自动调用执行的函数</strong>，为开发人员在不同阶段操作组件提供了时机。</p>
<table>
<thead>
<tr>
<th>钩子 函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>constructor</td>
<td>创建组件时，最先执行</td>
<td>1. 初始化state  2. 创建Ref等</td>
</tr>
<tr>
<td>render</td>
<td>每次组件渲染都会触发</td>
<td>渲染UI</td>
</tr>
<tr>
<td>componentDidMount</td>
<td>组件挂载（完成DOM渲染）后</td>
<td>1. 发送网络请求   2.DOM操作</td>
</tr>
<tr>
<td>componentDidUpdate</td>
<td>组件更新（完成DOM渲染）后</td>
<td>DOM操作，可以获取到更新后的DOM内容</td>
</tr>
<tr>
<td>componentWillUnmount</td>
<td>组件卸载（从页面中消失）</td>
<td>执行清理工作（比如：清理定时器等）</td>
</tr>
</tbody></table>
<h3 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1. 挂载阶段"></a>1. 挂载阶段</h3><p>执行时机：组件创建时（页面加载时）</p>
<p>执行顺序：constructor() -&gt; render() -&gt; componentDidMount()</p>
<h3 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2. 更新阶段"></a>2. 更新阶段</h3><p>更新阶段会执行两个钩子： render() -&gt; componentDidUpdate()</p>
<p>三种方法可以触发组件更新</p>
<ul>
<li>调用 setState 。它能改数据并且更新页面</li>
<li>调用forceUpdate() </li>
<li>组件接收到新的 props</li>
</ul>
<h3 id="3-卸载阶段"><a href="#3-卸载阶段" class="headerlink" title="3. 卸载阶段"></a>3. 卸载阶段</h3><p>执行时机：组件销毁</p>
<p>定时器和一些事件不会随着组件的销毁而被移除, 故在卸载阶段可以执行清理工作</p>
<h2 id="15-组件性能优化"><a href="#15-组件性能优化" class="headerlink" title="15. 组件性能优化"></a>15. 组件性能优化</h2><p>在完成功能的前提下做性能优化,有两点</p>
<ul>
<li>减轻 state: 只存储跟组件渲染相关的数据(比如：count &#x2F; 列表数据 &#x2F; loading 等), 不做渲染的数据不放在 state 中, 比如定时器 id 等</li>
<li>避免不必要的重新渲染: 由于组件的更新机制导致父组件更新子组件也跟着更新, 当子组件数据没有变化时也会跟随父组件重新渲染, 可以通过钩子函数<code>shouldComponentUpdate(nextProps, nextState)</code> 来控制该组件是否重新渲染, 其是一个更新阶段的钩子函数, 在组件重新渲染前执行</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="comment">// 执行顺序是 shouldComponentUpdate() =&gt; render()</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据条件，决定是否重新渲染组件 true 表示重新渲染</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>纯组件: 即 <code>React.PureComponent</code> , 与 <code>React.Component  </code>功能相似,其内部自动实现了 <code>shouldComponentUpdate</code> 钩子函数,无需手动比较</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件</span></span><br><span class="line"><span class="comment">// 在性能优化的时候可能会用到纯组件，请勿所有组件都使用纯组件，因为纯组件需要消耗性能进行对比</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        	<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>纯组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="16-Hooks"><a href="#16-Hooks" class="headerlink" title="16. Hooks"></a>16. Hooks</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p><strong>Hooks 只能在函数组件中使用</strong></p>
</blockquote>
<p>Hooks 是 React 16.8 的新增特性, 是一些可以让你在函数式组件里使用 React state 及生命周期等特性的函数. 为 <strong>函数组件</strong> 提供状态、生命周期等原本 在 Class 组件中才提供的功能.</p>
<h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h3><p>类组件之间很少继承,也很少相互访问, <strong>根据状态来渲染UI这件事</strong> 上发挥的并不好</p>
<p>而函数式组件本身简单,更好胜任这件事,通过 hooks 让组件有了维护状态的能力,也提升了组件的逻辑复用能力</p>
<h3 id="3-使用策略"><a href="#3-使用策略" class="headerlink" title="3. 使用策略"></a>3. 使用策略</h3><p>react 没有计划移除 class , 故 hooks 和现有代码可以同时工作, 推荐渐进式的使用,如 新功能用 hooks , 复杂功能实现不了的继续用 class </p>
<h3 id="4-核心-API"><a href="#4-核心-API" class="headerlink" title="4. 核心 API"></a>4. 核心 API</h3><h4 id="1-useState"><a href="#1-useState" class="headerlink" title="1.   useState"></a>1.   useState</h4><p>​	在函数式组件中使用状态时使用, 其可以为函数式组件提供状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入调用函数, useState 是 hook，hook是 use 开头的函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Count</span> = (<span class="params"></span>) =&gt; &#123;  </span><br><span class="line">  <span class="comment">// 返回值是一个数组  0 是状态初始值, 可以是任意值,这点跟 class 组件有所不同</span></span><br><span class="line">  <span class="comment">// class 组件中的 state 必须是一个对象</span></span><br><span class="line">  <span class="keyword">const</span> stateArray = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 状态值 =&gt; 0 </span></span><br><span class="line">  <span class="keyword">const</span> state = stateArray[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 修改状态值的函数 =&gt; 1</span></span><br><span class="line">  <span class="keyword">const</span> setState = stateArray[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">// 可以使用数组解构简化代码,这也是开发中最常用的</span></span><br><span class="line">  <span class="comment">// 解构名称可以自定义,但一般须带有意义, 且修改的函数一般以 set 开头后面跟上状态名称</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 展示状态值 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>useState Hook -&gt; &#123;state&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 点击按钮，让状态值 +1 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState(state + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useState 有两种格式</p>
<ul>
<li>直接传入初始值: 如  <code>useState(0)</code>   <code>useState(&#39;abc&#39;)</code></li>
<li>传入回调函数: 如 <code>useState(() =&gt; &#123; return 初始值 &#125;)</code> , 返回值就是当前状态的值  , 该回调函数只会执行一次,  当组件第一次渲染会执行初始状态, 当状态值发生改变时会导致页面第二次渲染, 此时组件中代码逻辑会再次执行, 即会再次调用 useState(0) , 但此时的结果会是最新的状态值而非初始值</li>
</ul>
<h4 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2.  useEffect"></a><strong>2.  useEffect</strong></h4><blockquote>
<p>effect 只能是一个同步函数，不能使用 async</p>
</blockquote>
<p>  事物的主要作用之外的，就是副作用. 在函数式组件中, 主作用是根据数据和状态渲染 UI, 除此之外的操作都可以称之为副作用, 主要包括数据请求、手动修改 DOM、开启&#x2F;清空定时器，添加事件监听，删除事件, localStorage 操作等</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 useEffect 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 2. 使用 useEffect ,传入回调函数, 可以多次定义并顺序执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 1 执行了,可以做副作用&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只传入回调函数时, 每次页面重新渲染所有副作用函数都会再次执行,这显然是没必要的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//  不带第二个参数,会导致每次页面更新都会执行 </span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 2 执行了,可以做副作用&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 解决: 第二个参数传入执行副作用函数的依赖项, 它决定了什么时机执行回调函数</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. 带第二个参数,参数是空数组,这样只会在组件渲染时执行一次,一般发请求或事件绑定时会使用</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 1 执行了,可以做副作用&#x27;</span>)</span><br><span class="line">&#125;, []) <span class="comment">// 这种情况只会执行一次</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 2. 带第二个参数(数组格式),并指定依赖项,会初始执行一次,并在依赖项的值发生变化时继续执行</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 1 执行了,可以做副作用&#x27;</span>)</span><br><span class="line">&#125;,[count, list]) <span class="comment">// 初始执行一次, 等 count 和 list 值发生变化才会再执行</span></span><br><span class="line"><span class="comment">// 回调函数还能返回一个清理函数,用来清理副作用</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 1 执行了,可以做副作用&#x27;</span>)</span><br><span class="line">    <span class="comment">// 清理函数会在组件卸载时以及下一次副作用函数调用之前执行</span></span><br><span class="line">    <span class="comment">// 类似于 class 中的 componentWillUnmount</span></span><br><span class="line">    <span class="keyword">return</span> （）=&gt;&#123; <span class="comment">/* 做清理工作*/</span> &#125; <span class="comment">// 清理函数</span></span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p><strong>将组件状态逻辑提取到可重用的函数（自定义 Hooks）中，实现状态逻辑复用。</strong></p>
<p>除了使用内置的 Hooks ，还能创建自己的 Hooks(自定义 Hooks)来实现不同状态的<strong>逻辑复用</strong></p>
<ul>
<li>自定义 Hooks 是一个函数，<strong>约定函数名称必须以 use 开头，React 就是通过函数名称是否以 use 开头来判断是不是 Hooks</strong></li>
<li>Hooks 只能在函数组件中或其他自定义 Hooks 中使用，否则，会报错！</li>
<li>自定义 Hooks 用来提取组件的状态逻辑，根据不同功能可以有不同的参数和返回值（就像使用普通函数一样）</li>
</ul>
<h4 id="3-useRef"><a href="#3-useRef" class="headerlink" title="3. useRef"></a>3. useRef</h4><p>在 React 中进行 DOM 操作时，用来获取 DOM, 其作用是 <strong>返回一个带有 current 属性的可变对象，通过该对象就可以进行 DOM 操作了。</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 useRef</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 获取 dom 时一般都设置为 null , 返回值是一个包含 current 属性的对象</span></span><br><span class="line"><span class="comment">// 只要在 React 中进行 DOM 操作，都能通过 useRef 来获取 DOM（比如，获取 DOM 的宽高等）</span></span><br><span class="line"><span class="comment">// useRef 不仅仅可以用于获取当前组件 DOM ，还可以获取子组件 dom</span></span><br><span class="line"><span class="comment">// ref 不能使用在函数式组件上，因为函数式组件没有实例！要配合 forwardRef 使用!</span></span><br><span class="line"> <span class="keyword">const</span> refTxt = <span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">// 获取 dom</span></span><br><span class="line"> <span class="keyword">const</span> refCom1 = <span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">// 获取组件 dom</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(refTxt) <span class="comment">// &#123; current: null &#125; 初次渲染是 null</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">click</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(refTxt, refCom1) <span class="comment">// &#123; current: input &#125; &#123; current: Com1 &#125; </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(refCom1.<span class="property">current</span>.<span class="property">state</span>.<span class="property">a</span>) <span class="comment">// 100</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(refTxt.<span class="property">current</span>.<span class="property">value</span>) <span class="comment">// &#x27; &#x27;</span></span><br><span class="line">    refTxt.<span class="property">current</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      useRef, <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;refTxt&#125;</span> /&gt;</span>&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;click&#125;</span>&gt;</span>点击，获取input中的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Com1</span> <span class="attr">ref</span>=<span class="string">&#123;refCom1&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>函数式组件有一个缺点,就是无法在多次渲染之间共享数据, 这个问题可以通过  useRef 来解决</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> timeId = <span class="literal">null</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(timeId) <span class="comment">// null </span></span><br><span class="line">  <span class="keyword">const</span> timeRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// timeRef.current = 你需要在多次渲染之间共享的数据</span></span><br><span class="line">  <span class="comment">// 这个方法返回的 ref 对象在组件整个生命周期内不变</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timeRef.<span class="property">current</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当执行 setCount 时组件会重新渲染, 而当重新渲染时会重复执行 let timeId = null</span></span><br><span class="line">    <span class="comment">// 这就导致 timeId 被重置了 无法保存也无法清除, 通过调用 useRef 解决这个问题</span></span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">count</span>) =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(timeRef.<span class="property">current</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">hClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(timeRef.<span class="property">current</span>) <span class="comment">// 关闭根组件严格模式才会生效</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(timeRef.<span class="property">current</span>) <span class="comment">// 直接清除无效 通过 useRef 清理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      count:&#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;hClick&#125;</span>&gt;</span>点击停止定时器<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-useContext"><a href="#4-useContext" class="headerlink" title="4. useContext"></a>4. useContext</h4><p>useContext 可以帮助我们跨越组件层级直接传递变量，实现数据共享。</p>
<p>其作用就是对组件所包含的所有后代组件提供全局的共享数据</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用步骤分为三步: 1. 导入并调用该方法,然后在当前组件导出</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Context</span> &#125; = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="comment">// 2. 在当前组件使用 Provider 包裹根组件,并通过 value 属性提供要共享的数据</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">这里放要传递的数据</span> &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">  	<span class="tag">&lt;<span class="name">根组件的内容</span>/&gt;</span></span></span><br><span class="line">  &lt;/<span class="title class_">Provider</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 3. 在任意后代组件中，导入 useContext 和 Context ,调用并接收数据即可使用</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Context</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span></span><br><span class="line"><span class="keyword">const</span> 函数组件 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> 公共数据 = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    <span class="keyword">return</span> ( 函数组件的内容 )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-redux"><a href="#17-redux" class="headerlink" title="17. redux"></a>17. redux</h2><blockquote>
<p>Redux 并不只为 react 应用提供状态管理， 它还支持其它的框架。</p>
</blockquote>
<h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>Redux 是 JavaScript 应用的状态容器，提供可预测的状态管理。类似于 Vue 中的 Vuex.</p>
<p>其作用是 <strong>集中式存储和管理应用的状态</strong>, 能简化组件之间通讯问题,数据流清晰</p>
<p>分为<strong>三个核心概念</strong></p>
<h4 id="2-action"><a href="#2-action" class="headerlink" title="2. action"></a>2. action</h4><p>action 是一个 js 对象, 包含了两个属性, 分别是 </p>
<ul>
<li>type: 标识属性, 值是字符串. 用来区分操作的动作</li>
<li>payload: 数据属性,是一个可选属性, 表示本次动作携带的数据</li>
</ul>
<p>其只是描述了<strong>有事情发生</strong>, 无法更新 state 数据, 更新数据交给 reducer 来处理</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际开发中常根据动作的不同设置不同的单独 action 文件</span></span><br><span class="line">&#123; type： <span class="string">&#x27;decrement&#x27;</span>, count： <span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// 类型文件一般也是单独设置文件夹然后导入使用, 更方便开发与维护</span></span><br><span class="line"><span class="comment">// 单独文件 constant.js 中导出类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="string">&#x27;todos/add&#x27;</span></span><br><span class="line"><span class="comment">// action 中导入类型</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">ADD</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addListAction</span> = (<span class="params">payload</span>) =&gt; (&#123;<span class="attr">type</span>: <span class="variable constant_">ADD</span>, payload&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-reducer"><a href="#3-reducer" class="headerlink" title="3. reducer"></a>3. reducer</h4><p>reducer 是一个<strong>纯函数</strong> , 只负责<strong>初始化状态</strong>和<strong>修改状态</strong>,  即根据传入的 action，返回新状态</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = [ &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;吃饭&#x27;</span>, <span class="attr">isDone</span>: <span class="literal">false</span>&#125; ]</span><br><span class="line"><span class="comment">// 一般而言会定义初始状态, 即第一次返回的值</span></span><br><span class="line"><span class="comment">// state 代表上一次的状态数据, action 代表所需要执行的动作和数据,可以解构</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = initState, &#123;type, payload&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="comment">// 返回新的state</span></span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;addN&#x27;</span>:</span><br><span class="line">      <span class="comment">// 返回新的state</span></span><br><span class="line">      <span class="keyword">return</span> state + payload</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际开发中也会根据实际情况设置不同的 reducer 文件, 通过目录下的 index 整合到一起</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">// 导入不同的处理 reducer 文件,通过 combineReducers 方法整合到一起</span></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">&#x27;./todos&#x27;</span></span><br><span class="line"><span class="keyword">import</span> filter <span class="keyword">from</span> <span class="string">&#x27;./filter&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  filter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="4-store"><a href="#4-store" class="headerlink" title="4. store"></a>4. store</h4><p>是 redux 的核心, 主要是整合 action 和 reducer. 有以下特点</p>
<ul>
<li>一个项目<strong>只有一个 store</strong></li>
<li>维护应用的状态，通过 <code>store.getState()</code> 获取初始状态</li>
<li>创建 store 时<strong>接收 reducer 作为参数</strong>：<code>const store = createStore(reducer)</code></li>
<li>发起状态更新时，需要分发 action：<code>store.dispatch(action)</code></li>
<li>状态更新后会触发 <code>store.subscribe(() =&gt; &#123;&#125;) </code>  函数, 通过该函数通知组件更新数据</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.subscribe 实际是添加了订阅者, 当状态更新后 store 会通知订阅者</span></span><br><span class="line"><span class="comment">// 在当前组件执行  store.subscribe 方法来更新页面</span></span><br><span class="line"><span class="keyword">const</span> [val, setVal] = <span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 状态改变时，执行相应操作</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据变化了....&#x27;</span>)</span><br><span class="line">  <span class="comment">// 定义空对象来更新页面</span></span><br><span class="line">  <span class="title function_">setVal</span>(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以通过 unSubscribe 取消订阅 取消监听状态变化</span></span><br><span class="line"><span class="title function_">unSubscribe</span>()</span><br><span class="line"><span class="comment">// 每个组件都这样设置太过繁琐, 可以在根组件设置,这样只要状态变更所有页面都会重新渲染</span></span><br><span class="line"><span class="comment">// 在 src/index.js 中设置, 由于 react 有 diff 算法所以对整体影响并不大</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)).<span class="title function_">render</span>( <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-Redux-代码执行过程"><a href="#5-Redux-代码执行过程" class="headerlink" title="5. Redux 代码执行过程"></a>5. Redux 代码执行过程</h4><h5 id="1-获取默认值"><a href="#1-获取默认值" class="headerlink" title="1. 获取默认值"></a>1. 获取默认值</h5><p>只要创建 store，Redux 就会调用一次 reducer， 且 type 是一个随机值, 确保第一次调用返回状态默认值, 即使用 <code>store.getState()</code> 方法所获取到的值</p>
<h5 id="2-更新状态"><a href="#2-更新状态" class="headerlink" title="2. 更新状态"></a>2. 更新状态</h5><p>在组件内需要更新状态时, 先分发动作  <code>store.dispatch(action)</code>  ,  redux 内部就会调用 reducer , 传入上一次的状态 state 和动作 action , 等待 reducer 执行完毕后返回最新状态, 最后 store 用最新状态替换旧状态, 此时状态更新完毕</p>
<h5 id="3-通知订阅者"><a href="#3-通知订阅者" class="headerlink" title="3. 通知订阅者"></a>3. 通知订阅者</h5><p>状态更新完毕后, store 会通知订阅者, 即执行  <code> store.subscribe</code> 这个方法</p>
<h2 id="18-React-redux"><a href="#18-React-redux" class="headerlink" title="18. React-redux"></a>18. React-redux</h2><p>由于 redux 并不只为 react 应用提供状态管理， 它还支持其它的框架。所以在 react 中直接使用 redux 很不方便, 如</p>
<ul>
<li>每个组件都需要单独导入 store </li>
<li>通知订阅者写在根组件上写法不友好</li>
</ul>
<p>故官方推出了 React-redux 库来解决这些问题, 完美融入 react, 有三个核心 API</p>
<h4 id="1-Provider"><a href="#1-Provider" class="headerlink" title="1. Provider"></a>1. Provider</h4><p>解决每个组件都需导入 store 的问题,  将 Provider 包裹在根组件上</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)).<span class="title function_">render</span>(</span><br><span class="line">  <span class="comment">// 使用 Provider 包裹根组件,所有组件不用再导入 store 了</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;</span> <span class="attr">store</span> &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-useSelector"><a href="#2-useSelector" class="headerlink" title="2. useSelector"></a>2. useSelector</h4><p>用来获取公共状态, 代替了 <code>store.getState()</code> 方法, 且 state 状态变化后会自动更新</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useSelector&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// const 状态 = useSelector(store的数据 =&gt; 你需要的部分)</span></span><br><span class="line"><span class="comment">// state 包含所有的 store 状态数据, 可以通过回调函数筛选需要的部分</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">todos</span> )</span><br></pre></td></tr></table></figure>

<h4 id="3-useDispatch"><a href="#3-useDispatch" class="headerlink" title="3. useDispatch"></a>3. useDispatch</h4><p>用来派发 action 动作, 通知 store 更新状态. 需先调用方法得到返回值再来执行</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="comment">// 先调用方法得到 dispatch 函数</span></span><br><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line"><span class="comment">// 调用 dispatch 方法传入 action 动作 , 实际开发中 action 会单独定义好导入调用执行</span></span><br><span class="line"><span class="keyword">import</span> &#123; sendAction &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/action&#x27;</span></span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">sendAction</span>())</span><br></pre></td></tr></table></figure>



<h2 id="19-redux-中间件"><a href="#19-redux-中间件" class="headerlink" title="19. redux 中间件"></a>19. redux 中间件</h2><p>默认情况下，Redux 自身只能处理同步数据流。但是在实际项目开发中，状态的更新、获取，通常是使用异步操作来实现。而 Redux 无法直接实现,就需要通过 Redux 中间件机制来实现</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>中间件，可以理解为处理一个功能的中间环节 , 用来在不损害原功能的前提下，引入额外的代码来拓展功能</p>
<ul>
<li>优势：可以串联、组合，在一个项目中使用多个中间件</li>
</ul>
<p><strong>Redux 中间件用来处理状态更新，也就是在状态更新的过程中，执行一系列的相应操作</strong></p>
<h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>无中间件时:  <strong><code>dispatch(action) =&gt; reducer</code></strong></p>
<p>Redux 中间件执行时机：<strong>dispatch(action) &#x3D;&gt; 执行中间件代码 &#x3D;&gt; reducer</strong></p>
<p>引入中间件后 触发 dispatch 方法执行的是中间件封装处理后的 dispatch , 其最终一定会调用Redux 库自己提供的 dispatch 方法</p>
<p>有以下常见中间件</p>
<h4 id="1-redux-thunk"><a href="#1-redux-thunk" class="headerlink" title="1. redux-thunk"></a>1. redux-thunk</h4><p>​	该中间件允许 redux 处理函数形式的 action , 这样在函数内部就可以执行异步操作,通常用来发	异步请求</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前异步操作都写在组件中, 请求到数据再创建 action,这使得维护非常不便</span></span><br><span class="line"><span class="comment">// 1. 先安装注册  yarn add redux-thunk 在 store/index.js 中注册</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="comment">// redux 提供了 applyMiddleware 方法来注册中间件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(rootReducer, <span class="title function_">applyMiddleware</span>(thunk))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个函数, 形参就是 dispatch </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addTodo</span> = (<span class="params">name</span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> 异步动作()</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;todos/add&#x27;</span>, <span class="attr">payload</span>: name&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件中调用传参</span></span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(<span class="string">&#x27;学习redux&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="2-redux-logger"><a href="#2-redux-logger" class="headerlink" title="2. redux-logger"></a>2. redux-logger</h4><p>该中间件可以追踪 redux 的操作日志, 在控制台打印出日志信息</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装 yarn add redux-logger 导入 store/index.js 中注册</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="comment">// 多个中间件可以用逗号隔开, 但是 logger 必须设置成最后一中间件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer, <span class="title function_">applyMiddleware</span>(thunk, logger))</span><br></pre></td></tr></table></figure>



<h4 id="3-redux-devtools-extension"><a href="#3-redux-devtools-extension" class="headerlink" title="3. redux-devtools-extension"></a>3. redux-devtools-extension</h4><p>引入该中间件, 能通过 chrome 开发者工具调试跟踪 redux 状态.</p>
<blockquote>
<p>需先安装 react 和 redux 的开发者工具</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需先安装 react  redux  开发者工具 即 chrome 浏览器插件</span></span><br><span class="line"><span class="comment">// 注册方式跟其他中间件有些不一样,须通过 composeWithDevTools 包裹所有中间件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, <span class="title function_">composeWithDevTools</span>(<span class="title function_">applyMiddleware</span>(中间件..)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



<h2 id="20-React-路由"><a href="#20-React-路由" class="headerlink" title="20. React 路由"></a>20. React 路由</h2><p>众所周知，路由是一套映射关系。在 React 中路由是指路径和组件的对应关系</p>
<p>简单来说就是配置路径和组件（配对）</p>
<h4 id="模拟-hash-路由"><a href="#模拟-hash-路由" class="headerlink" title="模拟 hash 路由"></a>模拟 hash 路由</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心思路就是维护 hash 的状态， 当状态变化时修改它，根据 hash 的值来决定显示哪个组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./pages/Home.jsx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Search</span> <span class="keyword">from</span> <span class="string">&#x27;./pages/Search.jsx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Comment</span> <span class="keyword">from</span> <span class="string">&#x27;./pages/Comment.jsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span> () &#123;</span><br><span class="line">	<span class="comment">// 记录 hash 的状态</span></span><br><span class="line">  <span class="keyword">const</span> [curHash, setCurHash] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// console.log(window.location.hash)</span></span><br><span class="line">      <span class="title function_">setCurHash</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onChange</span>()</span><br><span class="line">      <span class="comment">// 页面加载 注册 hashchange 事件，当 hash 值发生变化时触发</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, onChange)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 清除注册的事件</span></span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, onChange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/comment&quot;</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/search&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;curHash === &#x27;/home&#x27; &amp;&amp; <span class="tag">&lt;<span class="name">Home</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;curHash === &#x27;/search&#x27; &amp;&amp; <span class="tag">&lt;<span class="name">Search</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;curHash === &#x27;/comment&#x27; &amp;&amp; <span class="tag">&lt;<span class="name">Comment</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>react 中使用需先下包 <code>react-router-dom</code> , 该包有 5 和 6 两个大的版本，改动较大</p>
<h4 id="5-X版本"><a href="#5-X版本" class="headerlink" title="5.X版本"></a>5.X版本</h4><blockquote>
<p>2021年8月出的5.3版本</p>
</blockquote>
<p>该版本有三个核心组件 <code>Router</code> ， <code>Route</code>，<code>Link</code></p>
<ul>
<li><p><strong>Router</strong>： 路由模式，用来包裹根组件。具体路由模式由引入的 router 决定</p>
</li>
<li><p><strong>HashRouter</strong>： 使用 URL 的哈希值实现，原理是监听 window 的<code>hashchange</code> 事件</p>
</li>
<li><p><strong>BrowserRouter</strong>：使用 H5 的 history.pushState() API 实现，监听 <code>popstate</code> 事件</p>
</li>
<li><p><strong>Link</strong>： 用于<strong>指定路由导航</strong>。最终渲染成 a 标签，to 属性渲染成 href 属性</p>
</li>
<li><p><strong>NavLink</strong>：一个特殊的 <code>Link</code> 组件，可以用于指定当前导航高亮</p>
</li>
<li><p><strong>Route</strong>：匹配路由规则，浏览器路径和 path 匹配成功就会显示该组件。path 代表浏览器路径，component 代表对应的组件，匹配成功不会停止，可能会匹配多个组件</p>
</li>
<li><p><strong>Switch</strong>：使用该组件可确保不管有多少路由规则匹配成功都只会渲染第一个匹配上的组件</p>
</li>
<li><p><strong>Redirect</strong>：路由路径重定向跳转。from 属性表示当前路径， to 表示要重定向的路径</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashRouter: hash 模式	BrowserRouter： history 模式</span></span><br><span class="line"><span class="comment">// 二者都需要包裹整个根组件，且一个项目中只能有一个 Router，一般都会重命名为 router</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>，<span class="title class_">Link</span>，<span class="title class_">Route</span>，<span class="title class_">NavLink</span>，<span class="title class_">Redirect</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">   <span class="comment">// 包裹根组件来接管项目路径</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>react路由基本使用<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/comment&quot;</span>&gt;</span>评论<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/search&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> // activeClassName 用于指定高亮的类名，默认 active 。一般不去修改。</span></span><br><span class="line"><span class="language-xml"> // NavLink 还有 exact 属性，表示精确匹配</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/search&quot;</span> <span class="attr">exact</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> //  Route 也有 exact 属性，表示精确匹配，默认是模糊匹配</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/comment&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Comment&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/search&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Search&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           // 一般路径匹配 / ，都需要配置 exact 属性 </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/article&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Article&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/article/123&quot;</span> <span class="attr">component</span>=<span class="string">&#123;ArticleDetail&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          // 重定向路由路径 ，一般加上 exact 属性</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&quot;/&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/comment&quot;</span> <span class="attr">exact</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          // 匹配 404 页面，不设置 path 属性，将对应路由放在 Switch 组件的最后位置</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;Page404&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h5><p>React 中页面跳转有两种方式，一种是通过 <strong><code> Link</code></strong> 标签点击跳转，一种是通过<strong>编程式导航</strong>跳转</p>
<p>react-router 中提供了 <code>useHistory</code> 这个  API 来实现编程式跳转</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 导入 useHistory 方法并调用，得到编程式跳转方法</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="title function_">useHistory</span>()</span><br><span class="line">  <span class="comment">// history 中有 push 方法来指定要跳转到哪个页面</span></span><br><span class="line">  history.<span class="title function_">push</span>(<span class="string">&#x27;/find&#x27;</span>）</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// history 中有 go 方法来前进或后退到某个页面</span></span><br><span class="line">  <span class="comment">// 参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）</span></span><br><span class="line">  history.<span class="title function_">go</span>(-<span class="number">1</span>) </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// history 中有 replace 方法来替换当前页面，并替换记录</span></span><br><span class="line">  <span class="comment">// 和 push 方法区别在于 push 方法会向历史记录中添加一条记录，而该方法会替换记录</span></span><br><span class="line">  history.<span class="title function_">replace</span>(<span class="string">&#x27;/frend&#x27;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h5><ul>
<li>params 传参：在 Route 上的 path 里通过 <code>/:id/:name</code> 的形式传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 &lt;Route path=&quot;/article/:age/:name&quot; component=&#123;Article&#125; /&gt;</span></span><br><span class="line"><span class="comment">// 在路径上会显示为 /article/18/jack  有两种方法接收传递的参数</span></span><br><span class="line"><span class="comment">// 1. 通过 props.match.params 接收</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">match</span>.<span class="property">params</span>)  <span class="comment">// &#123; age: 18, name: jack &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 通过 hooks 提供的 useParams 方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="title function_">useParams</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(params) <span class="comment">// &#123; age: 18, name: jack &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>search 传参： 在 Link 上通过 ?分隔，&amp;符号分连传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route 上无需特殊处理，Link 上用 ?分隔&amp;相连</span></span><br><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/layout/user?name=jack&amp;age=18&quot;</span>&gt;用户&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/layout/user&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Layout&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// 组件内用 props.location.search 接收，接受的参数需要单独处理编码</span></span><br><span class="line"><span class="comment">// 可以借助 query-string 包的 stringfy() 和 parse() 方法转换</span></span><br><span class="line"><span class="comment">// 还可以借助 querystring 包的 stringfy() 和 parse() 方法转换</span></span><br><span class="line"><span class="comment">// 构造函数 new URLSearchParams() 也可以，不过比较麻烦</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;query-string&#x27;</span></span><br><span class="line"><span class="keyword">import</span> querystring <span class="keyword">from</span> <span class="string">&#x27;querystring&#x27;</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(props.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">const</span> &#123;name,age &#125; = qs.<span class="title function_">parse</span>(props.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>state 传参： 在 Link 上通过 state&#x3D; 参数对象来传参</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Link 上传入一个 state 对象 组件内通过 props.location.state 来接收传递的对象</span></span><br><span class="line">&lt;<span class="title class_">Link</span> to=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/layout/user&#x27;</span>,<span class="attr">state</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;&gt;首页&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/layout/user&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Layout&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="comment">// state 可以任意起名，但是一般不变更名字。 刷新页面 state 不会丢失</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Layout</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">location</span>.<span class="property">state</span>) <span class="comment">//  &#123;name: &#x27;jack&#x27;, age: 18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h5><p>路由嵌套可以任意搭配，但是路径一定要一级一级匹配上，先匹配父级路由再匹配子路由</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 /home 可以匹配Home父组件  再通过/list匹配子组件</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home/list&quot;</span> component=&#123;<span class="title class_">List</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>



<h4 id="6-X-版本"><a href="#6-X-版本" class="headerlink" title="6.X 版本"></a>6.X 版本</h4><blockquote>
<p>2022年3月出的 6.3 版本</p>
</blockquote>
<p>将 <code>Switch</code> 升级为 <code>Routes</code>, 当路由嵌套时，子路由再无需补充完整路径而可以使用简短语法</p>
<p><code>Route </code> 中的子组件由 <code>component</code> 升级成 <code>element</code> , 且需使用标签写法</p>
<p>使用 <code>Route</code> 中的 <code>path</code> 路径 *  取代了 <code>&lt;Route exact&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span>, <span class="title class_">Routes</span>,<span class="title class_">Route</span>, <span class="title class_">Link</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"> <span class="comment">// 父级路由</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      // Routes 代替了 Switch</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // element 代替了 component</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;users/*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Users</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Users</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;me&quot;</span>&gt;</span>My Profile<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     //	<span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">pathname:</span> &quot;/<span class="attr">home</span>&quot;, <span class="attr">state:</span> <span class="attr">state</span> &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      // v6 中 升级了 Link 组件,让其可以单独使用 state</span></span><br><span class="line"><span class="language-xml">      	<span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">state</span>=<span class="string">&#123;state&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         // 不用再写 /users/me /users/:id 而可以直接写子路由这一级</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">UserProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;me&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">OwnUserProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编程式导航-1"><a href="#编程式导航-1" class="headerlink" title="编程式导航"></a>编程式导航</h5><p>用 <code>useNavigate</code> 代替了 <code>useHistory</code> , 有两个参数, <code> navigate(to, &#123; replace: true &#125;)</code> 用来替换当前页,  <code>navigate(to, &#123; state &#125;)</code> 用来接收参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React Router v6 引入了一个新的导航 API useNavigate , 代替了 v5 的 useHistory</span></span><br><span class="line"><span class="comment">// This is a React Router v5 app</span></span><br><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> history = <span class="title function_">useHistory</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    history.<span class="title function_">push</span>(<span class="string">&quot;/home&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>go home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a React Router v6 app</span></span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">navigate</span>(<span class="string">&quot;/home&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>go home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>使用 <code>Navigate</code> 代替了 <code>Redirect</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">replace</span> <span class="attr">state</span>=<span class="string">&#123;state&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change this:</span></span><br><span class="line">&lt;<span class="title class_">Redirect</span> to=<span class="string">&quot;about&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;home&quot;</span> <span class="attr">push</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// to this:</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span> <span class="attr">replace</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;home&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h5><p>简化了<code> go, goBack, goForward</code> 等方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a React Router v5 app</span></span><br><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; go, goBack, goForward &#125; = <span class="title function_">useHistory</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> go(-2)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Go 2 pages back</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;goBack&#125;</span>&gt;</span>Go back<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;goForward&#125;</span>&gt;</span>Go forward<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> go(2)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Go 2 pages forward</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a React Router v6 app</span></span><br><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(-2)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Go 2 pages back</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(-1)&#125;&gt;Go back<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Go forward</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(2)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Go 2 pages forward</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://metabo6.github.io">随时奉陪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://metabo6.github.io/posts/4f68be61.html">https://metabo6.github.io/posts/4f68be61.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://metabo6.github.io" target="_blank">随时奉陪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/react.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/cac7ea72.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/npm.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NODE常见第三方包</div></div></a></div><div class="next-post pull-right"><a href="/posts/cd25c3da.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/react.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React 移动端总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly/index.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随时奉陪</div><div class="author-info__description">向往自由，追求自由，找寻自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/metabo6"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React-%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">React 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1. 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-React-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2. React 脚手架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">3. 项目目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JSX-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4. JSX 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JSX-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.JSX 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JSX-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. JSX 列表渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JSX-%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. JSX 样式处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-eslint-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text">5. eslint 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">1.5.1.</span> <span class="toc-text">目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%A7%E5%8E%82-UI-%E5%BA%93"><span class="toc-number">1.6.</span> <span class="toc-text">6. 大厂 UI 库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-react-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.</span> <span class="toc-text">7. react 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 函数式组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 类组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.组件状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 状态更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">8. 事件绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.</span> <span class="toc-text">9. 事件对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-this-%E6%8C%87%E5%90%91"><span class="toc-number">1.10.</span> <span class="toc-text">10. this 指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="toc-number">1.11.</span> <span class="toc-text">11. 获取表单元素的值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-ref"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 非受控组件-ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.11.2.</span> <span class="toc-text">2. 受控组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="toc-number">1.12.</span> <span class="toc-text">12. 组件通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%88%B6%E5%AD%90%E9%80%9A%E8%AE%AF"><span class="toc-number">1.12.1.</span> <span class="toc-text">1. 父子通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="toc-number">1.12.2.</span> <span class="toc-text">2. 兄弟组件通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%A8%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="toc-number">1.12.3.</span> <span class="toc-text">3. 跨组件通讯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BC%A0%E5%80%BC-props-%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.13.</span> <span class="toc-text">13. 传值 props 校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.14.</span> <span class="toc-text">14. 组件生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">1.14.1.</span> <span class="toc-text">1. 挂载阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">1.14.2.</span> <span class="toc-text">2. 更新阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">1.14.3.</span> <span class="toc-text">3. 卸载阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.15.</span> <span class="toc-text">15. 组件性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Hooks"><span class="toc-number">1.16.</span> <span class="toc-text">16. Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.16.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.16.2.</span> <span class="toc-text">2. 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5"><span class="toc-number">1.16.3.</span> <span class="toc-text">3. 使用策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83-API"><span class="toc-number">1.16.4.</span> <span class="toc-text">4. 核心 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-useState"><span class="toc-number">1.16.4.1.</span> <span class="toc-text">1.   useState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-useEffect"><span class="toc-number">1.16.4.2.</span> <span class="toc-text">2.  useEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-useRef"><span class="toc-number">1.16.4.3.</span> <span class="toc-text">3. useRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-useContext"><span class="toc-number">1.16.4.4.</span> <span class="toc-text">4. useContext</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-redux"><span class="toc-number">1.17.</span> <span class="toc-text">17. redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.17.0.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-action"><span class="toc-number">1.17.0.2.</span> <span class="toc-text">2. action</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-reducer"><span class="toc-number">1.17.0.3.</span> <span class="toc-text">3. reducer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-store"><span class="toc-number">1.17.0.4.</span> <span class="toc-text">4. store</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Redux-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.17.0.5.</span> <span class="toc-text">5. Redux 代码执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">1.17.0.5.1.</span> <span class="toc-text">1. 获取默认值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="toc-number">1.17.0.5.2.</span> <span class="toc-text">2. 更新状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%9A%E7%9F%A5%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">1.17.0.5.3.</span> <span class="toc-text">3. 通知订阅者</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-React-redux"><span class="toc-number">1.18.</span> <span class="toc-text">18. React-redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Provider"><span class="toc-number">1.18.0.1.</span> <span class="toc-text">1. Provider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-useSelector"><span class="toc-number">1.18.0.2.</span> <span class="toc-text">2. useSelector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-useDispatch"><span class="toc-number">1.18.0.3.</span> <span class="toc-text">3. useDispatch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-redux-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.19.</span> <span class="toc-text">19. redux 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.19.0.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">1.19.0.2.</span> <span class="toc-text">触发时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-redux-thunk"><span class="toc-number">1.19.0.3.</span> <span class="toc-text">1. redux-thunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-redux-logger"><span class="toc-number">1.19.0.4.</span> <span class="toc-text">2. redux-logger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-redux-devtools-extension"><span class="toc-number">1.19.0.5.</span> <span class="toc-text">3. redux-devtools-extension</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-React-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.20.</span> <span class="toc-text">20. React 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-hash-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.20.0.1.</span> <span class="toc-text">模拟 hash 路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.20.0.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-X%E7%89%88%E6%9C%AC"><span class="toc-number">1.20.0.3.</span> <span class="toc-text">5.X版本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-number">1.20.0.3.1.</span> <span class="toc-text">编程式导航</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">1.20.0.3.2.</span> <span class="toc-text">路由传参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-number">1.20.0.3.3.</span> <span class="toc-text">路由嵌套</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-X-%E7%89%88%E6%9C%AC"><span class="toc-number">1.20.0.4.</span> <span class="toc-text">6.X 版本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA-1"><span class="toc-number">1.20.0.4.1.</span> <span class="toc-text">编程式导航</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.20.0.4.2.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.20.0.4.3.</span> <span class="toc-text">页面跳转</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a5ae354f.html" title="数组、字符串常用方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/js.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组、字符串常用方法"/></a><div class="content"><a class="title" href="/posts/a5ae354f.html" title="数组、字符串常用方法">数组、字符串常用方法</a><time datetime="2022-11-24T02:24:11.000Z" title="发表于 2022-11-24 10:24:11">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b0de96e1.html" title="CSS 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/css.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS 总结"/></a><div class="content"><a class="title" href="/posts/b0de96e1.html" title="CSS 总结">CSS 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f1991798.html" title="Git 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/git.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 总结"/></a><div class="content"><a class="title" href="/posts/f1991798.html" title="Git 总结">Git 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50b39724.html" title="HTML 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/HTML.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML 总结"/></a><div class="content"><a class="title" href="/posts/50b39724.html" title="HTML 总结">HTML 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/588ad959.html" title="JS 基础总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/js.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS 基础总结"/></a><div class="content"><a class="title" href="/posts/588ad959.html" title="JS 基础总结">JS 基础总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 随时奉陪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>