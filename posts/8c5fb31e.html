<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue2 总结 | 随时奉陪</title><meta name="author" content="随时奉陪"><meta name="copyright" content="随时奉陪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue2 总结1. webpack webpack 是一个 node 第三方模块打包工具, 可以识别代码，翻译，压缩，整合打包，能减少文件数量，压缩代码体积，提高网页打开速度。  使用前需先初始化包环境，下载 webpack webpack-cli 等模块，最后在 package.json 中自定义"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://metabo6.github.io/posts/8c5fb31e"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue2 总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-24 11:01:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly/index.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-tags"></i><span> 仿 win10</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-folder-open"></i><span> 学习资料</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-anchor"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-place-of-worship"></i><span> 摸鱼大军</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/vue2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">随时奉陪</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-tags"></i><span> 仿 win10</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-folder-open"></i><span> 学习资料</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-fish"></i><span> 摸鱼</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-tools"></i><span> 工具</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-anchor"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-place-of-worship"></i><span> 摸鱼大军</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue2 总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-24T03:01:48.076Z" title="更新于 2022-11-24 11:01:48">2022-11-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue2 总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Vue2-总结"><a href="#Vue2-总结" class="headerlink" title="Vue2 总结"></a>Vue2 总结</h1><h3 id="1-webpack"><a href="#1-webpack" class="headerlink" title="1. webpack"></a>1. webpack</h3><ol>
<li><p>webpack 是一个 node 第三方模块打包工具, 可以识别代码，翻译，压缩，整合打包，能减少文件数量，压缩代码体积，提高网页打开速度。</p>
</li>
<li><p>使用前需先初始化包环境，下载 <code>webpack</code> <code>webpack-cli</code> 等模块，最后在 package.json 中自定义命令</p>
</li>
<li><p>使用需先配置入口文件，且将需要引用的文件导入到入口文件中才会参与打包，然后执行自定义的命令，最终生成打包后的 dist 文件夹中的 main.js</p>
</li>
<li><h6 id="webpack-配置修改：-分为入口，出口，打包模式，loader-加载器，plugins-插件配置"><a href="#webpack-配置修改：-分为入口，出口，打包模式，loader-加载器，plugins-插件配置" class="headerlink" title="webpack 配置修改： 分为入口，出口，打包模式，loader 加载器，plugins 插件配置"></a>webpack 配置修改： 分为入口，出口，打包模式，loader 加载器，plugins 插件配置</h6><ul>
<li>入口： 通过 <code>entry</code> 设置入口文件路径，可以是相对路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: &#x27;./src/main.js&#x27;, // 入口, 可以是相对路径</span><br></pre></td></tr></table></figure>

<ul>
<li>出口： 通过<code>output</code> 设置出口路径， 必须是绝对路径，还可以自定义出口文件名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123; <span class="comment">// 出口, 必须是绝对路径</span></span><br><span class="line">		<span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">		<span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>打包模式： 分为<code>production</code> 生产模式和 <code>development</code> 开发模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,	 <span class="comment">// production: 生产模式 development: 开发模式	</span></span><br></pre></td></tr></table></figure>

<ul>
<li>服务器配置：通过 <code>devServer</code> 设置端口号，打开方式， host 地址等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">		<span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">// 端口号</span></span><br><span class="line">		<span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>loader 加载器：webpack 默认只打包 js 文件，如需打包其他文件类型就需要配置对应的 loader 规则，通过配置 <code>loader</code> 让 webpack 有了打包其他文件类型的能力</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;	<span class="comment">// 配置 loader</span></span><br><span class="line">	<span class="attr">rules</span>: [	<span class="comment">// loader 规则 一个对象表示一个匹配规则</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">test</span>: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">			<span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">		&#125;，</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>plugins 插件：通过配置 <code>plugins</code>  能给 webpack 带来更多功能</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [ <span class="comment">//插件配置是一个数组，一个对象表示一个插件 通过 new 关键字生成实例对象</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>Source Map： 是一个信息文件，里面存储着代码的位置信息，开发环境下默认启用了该功能，当报错时可以提示错误的位置信息，但是记录的是压缩后的代码位置，会导致报错的行数与实际行数不一致，可通过配置<code>devtool</code> 保证行数一致，不受压缩代码的影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devtool</span>: <span class="string">&#x27;nosources-source-map&#x27;</span>, </span><br></pre></td></tr></table></figure>

<ul>
<li>resolve： 用于配置模块如何被解析，常见的如 <code>alias</code>，<code>modules</code>,<code>extensions</code>等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// modules 默认值是 [&#x27;node_modules&#x27;],指默认先去当前目录的 node_modules 里找模块，没找到就往上一级的 node_modules 找，一直没找到就报错</span><br><span class="line">	resolve: &#123;</span><br><span class="line">		modules: [path.resolve(__dirname,&#x27;node_modules&#x27;)],</span><br><span class="line">		alias: &#123;</span><br><span class="line">     	 &#x27;@&#x27;: path.join(__dirname, &#x27;./src/&#x27;)</span><br><span class="line">   		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">// extensions 默认值是[&quot;.wasm&quot;,&quot;.mjs&quot;,&quot;.js&quot;,&quot;.json&quot;],如果导入的模块没有扩展名，webpack 会根据设置的扩展名一 一查找，谁在前就先查找谁，所以导入 js 文件可以省略 .js</span><br><span class="line">// alias 是给文件路径取个别名，这样每次导入模块时就不用写一长串了，如 @  表示 src</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-脚手架"><a href="#2-脚手架" class="headerlink" title="2.脚手架"></a>2.脚手架</h3><pre><code>1. 脚手架是 Vue 官方提供的一套标准的文件夹+文件结构+ webpack 配置，快速搭建项目基本		环境，使用脚手架可以做到 0 配置，开箱即用，快速搭建项目基本开发环境
2. 使用脚手架需安装全局包，得到终端命令，然后创建脚手架项目
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 下包	yarn global add @vue/cli</span></span><br><span class="line"><span class="comment">// 2. 使用终端命令创建脚手架项目	vue create 项目名（名称不能带大写字母中文和特殊符号）</span></span><br></pre></td></tr></table></figure>

<p>​	3.  main.js 是项目打包入口，App.vue 是 vue 页面入口，index.html 是浏览器运行的文件，三者关系是 App.vue &#x3D;&gt; main.js &#x3D;&gt; index.html</p>
<pre><code>4. 配置文件由原来的 webpack 升级成了 vue.config.js
</code></pre>
<h3 id="3-Vue-概念及指令修饰符"><a href="#3-Vue-概念及指令修饰符" class="headerlink" title="3. Vue 概念及指令修饰符"></a>3. Vue 概念及指令修饰符</h3><ol>
<li><h5 id="Vue是一个JavaScript渐进式框架，渐进式就是按需逐渐集成功能，库是方法的集合，而框架是一套拥有自己规则的语法。学习-Vue-可以使开发更快速，更高效，且市场占有率高。"><a href="#Vue是一个JavaScript渐进式框架，渐进式就是按需逐渐集成功能，库是方法的集合，而框架是一套拥有自己规则的语法。学习-Vue-可以使开发更快速，更高效，且市场占有率高。" class="headerlink" title="Vue是一个JavaScript渐进式框架，渐进式就是按需逐渐集成功能，库是方法的集合，而框架是一套拥有自己规则的语法。学习 Vue 可以使开发更快速，更高效，且市场占有率高。"></a>Vue是一个JavaScript渐进式框架，渐进式就是按需逐渐集成功能，库是方法的集合，而框架是一套拥有自己规则的语法。学习 Vue 可以使开发更快速，更高效，且市场占有率高。</h5></li>
<li><h5 id="vue-指令，官方封装好的指令"><a href="#vue-指令，官方封装好的指令" class="headerlink" title="vue 指令，官方封装好的指令"></a>vue 指令，官方封装好的指令</h5></li>
</ol>
<table>
<thead>
<tr>
<th>指令名</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>v-bind</td>
<td>给标签动态绑定属性值</td>
<td>可以简写成 :属性名&#x3D;‘属性值’</td>
</tr>
<tr>
<td>v-on</td>
<td>给标签绑定事件，还带有修饰符，包括事件修饰符和按键修饰符</td>
<td>简写 @事件名&#x3D;‘事件处理函数’，不带参数默认第一个参数是事件对象，带参数用 $event 代替事件对象</td>
</tr>
<tr>
<td>v-if</td>
<td>使标签显示或隐藏，当值为 true时显示</td>
<td>本质是添加或者移除 dom 元素</td>
</tr>
<tr>
<td>v-show</td>
<td>使标签显示或隐藏，当值为 true时显示</td>
<td>本质是修改 dom 元素的 display 为 none</td>
</tr>
<tr>
<td>v-for</td>
<td>在标签上使用循环创建标签</td>
<td>必须带 key 值，key 值不能重复</td>
</tr>
<tr>
<td>v-html</td>
<td>设置标签显示的内容</td>
<td>可以解析标签名</td>
</tr>
<tr>
<td>v-text</td>
<td>设置标签显示的内容</td>
<td>不能解析标签名</td>
</tr>
<tr>
<td>v-model</td>
<td>在表单标签上可以双向绑定标签的 value</td>
<td>在 select 上绑定的是 option 的 value 值，多选框绑定的是 checked 值</td>
</tr>
</tbody></table>
<ol start="3">
<li><h5 id="修饰符：事件修饰符"><a href="#修饰符：事件修饰符" class="headerlink" title="修饰符：事件修饰符"></a>修饰符：事件修饰符</h5></li>
</ol>
<table>
<thead>
<tr>
<th>修饰符名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.stop</td>
<td>阻止事件冒泡</td>
</tr>
<tr>
<td>.prevent</td>
<td>阻止默认事件</td>
</tr>
<tr>
<td>.lazy</td>
<td>让事件只触发一次</td>
</tr>
<tr>
<td>@keyup.enter</td>
<td>监测回车按键</td>
</tr>
<tr>
<td>@keyup.esc</td>
<td>监测 esc 返回按键</td>
</tr>
<tr>
<td>v-model.number</td>
<td>以 parseFloat 转成数字类型</td>
</tr>
<tr>
<td>v-model.trim</td>
<td>去除首尾空白字符</td>
</tr>
<tr>
<td>v-model.lazy</td>
<td>在 change 时触发而非 inupt 时</td>
</tr>
<tr>
<td>.once</td>
<td>只执行一次这个事件</td>
</tr>
</tbody></table>
<ol start="4">
<li><h5 id="插值表达式：在标签里面可以使用双大括号包裹表达式，转换成表达式结果展示"><a href="#插值表达式：在标签里面可以使用双大括号包裹表达式，转换成表达式结果展示" class="headerlink" title="插值表达式：在标签里面可以使用双大括号包裹表达式，转换成表达式结果展示"></a>插值表达式：在标签里面可以使用双大括号包裹表达式，转换成表达式结果展示</h5></li>
<li><h5 id="MVVC-：是种软件架构模式，通过数据双向绑定让数据自动的双向同步，减少操作-dom-，提高开发效率"><a href="#MVVC-：是种软件架构模式，通过数据双向绑定让数据自动的双向同步，减少操作-dom-，提高开发效率" class="headerlink" title="MVVC ：是种软件架构模式，通过数据双向绑定让数据自动的双向同步，减少操作 dom ，提高开发效率"></a>MVVC ：是种软件架构模式，通过数据双向绑定让数据自动的双向同步，减少操作 dom ，提高开发效率</h5><ul>
<li>M：   model数据模型          (data里定义)	</li>
<li>V：    view视图                   （页面标签）</li>
<li>VM： ViewModel视图模型  (vue.js源码)</li>
</ul>
</li>
<li><h5 id="MVC-也是一种设计模式-组织代码的结构-是model数据模型-view视图-Controller控制器-在控制器这层里编写js代码-来控制数据和视图关联"><a href="#MVC-也是一种设计模式-组织代码的结构-是model数据模型-view视图-Controller控制器-在控制器这层里编写js代码-来控制数据和视图关联" class="headerlink" title="MVC: 也是一种设计模式, 组织代码的结构, 是model数据模型, view视图, Controller控制器, 在控制器这层里编写js代码, 来控制数据和视图关联"></a>MVC: 也是一种设计模式, 组织代码的结构, 是model数据模型, view视图, Controller控制器, 在控制器这层里编写js代码, 来控制数据和视图关联</h5></li>
</ol>
<h3 id="4-v-for"><a href="#4-v-for" class="headerlink" title="4. v-for"></a>4. v-for</h3><p>v-for 循环中，有一个监测机制，当修改循环的数组时</p>
<ul>
<li>直接修改原数组会触发机制，更新页面</li>
<li>没有修改原数组，通过赋值给原数组也会触发</li>
<li>通过下标修改数组数据，或者通过数组的一些方法如<code>slice</code> 、<code>filter</code> 、<code>concat</code> 等直接修改也不会触发机制，不会造成页面刷新</li>
<li>如果通过以上方法修改数组不造成页面更新，可以通过 <code>this.$set()</code> 方法来触发页面更新</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.$set(a,b,c);	a 表示要修改的对象或数组	b 表示要修改的属性，对象用字符串的键表示，数组用下标数字表示		c 是要修改的值 </span></span><br><span class="line"><span class="comment">// 通过这个方法可以修改 v-for 监测不到的数据修改，更新页面</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">arr</span>: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="title function_">updateBtn</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">//   this.arr[0] = 1000; 直接修改页面不会更新</span></span><br><span class="line">        <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arr</span>, <span class="number">0</span>, <span class="number">1000</span>); <span class="comment">// 页面更新</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;     </span><br></pre></td></tr></table></figure>

<p>当数据发生变化时， Vue 会尽可能的就地复用来更新数据</p>
<ul>
<li>无 key 会尽可能就地复用</li>
<li>有 id 优先用 id，无 id 用索引</li>
<li>key 值不能重复，且必须是数字或字符串</li>
</ul>
<p>.vue文件中的template里写的标签, 都是模板, 都要被vue处理成虚拟DOM对象, 再生成真实DOM片段, 才会渲染显示到真实DOM页面上</p>
<ul>
<li>虚拟 dom：本质就是一个JS对象, 保存DOM关键信息</li>
<li>可以提高DOM更新的性能, 不频繁操作真实DOM, 在内存中找到变化部分, 更新真实DOM(打补丁)</li>
</ul>
<h3 id="5-动态-class-和动态-style"><a href="#5-动态-class-和动态-style" class="headerlink" title="5. 动态 class 和动态 style"></a>5. 动态 class 和动态 style</h3><p>用 v-bind 给标签 class 、style 设置动态的值，当满足条件时该类名才会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p :<span class="keyword">class</span>=<span class="string">&quot;&#123;类名: 布尔值&#125;&quot;</span>&gt;动态<span class="keyword">class</span>&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;css 属性名: 属性值&#125;&quot;</span>&gt;</span>动态style<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-计算属性-computed"><a href="#6-计算属性-computed" class="headerlink" title="6. 计算属性 computed"></a>6. 计算属性 computed</h3><p>计算属性，就是定义一个数据，数据本身依赖另一些数据计算而得来的结果，计算的结果带有缓存特性，当依赖的数据没有发生变化时，会读取缓存的值，当依赖的数据发生变化才会触发重新计算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只读取不赋值可以使用简单写法,此处的属性名可以直接在页面使用</span></span><br><span class="line">computed : &#123;</span><br><span class="line">    属性名 (新值，旧值)&#123;</span><br><span class="line">    <span class="keyword">return</span> 值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整写法 又需要读取又要进行赋值操作</span></span><br><span class="line">computed : &#123;</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">新值</span>)&#123;</span><br><span class="line">    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;,</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">新值，旧值</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> 值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-侦听器-watch"><a href="#7-侦听器-watch" class="headerlink" title="7.侦听器 watch"></a>7.侦听器 watch</h3><p>当 data&#x2F;computed 属性值发生变化时可以触发对应函数，侦听数据的变化，只有当数据发生变化才会触发，不变化不触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单侦听，只能侦听简单数据类型</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">	<span class="string">&quot;被侦听的属性名&quot;</span> (newVal, oldVal)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 深度侦听，可以侦听对象和数组等复杂数据类型</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="string">&quot;要侦听的属性名&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span>, <span class="comment">// 深度侦听复杂类型内变化</span></span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span>,	<span class="comment">// 立即侦听，控制侦听器是否立即触发，默认值是 false</span></span><br><span class="line">        handler (newVal, oldVal) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-组件"><a href="#8-组件" class="headerlink" title="8.组件"></a>8.组件</h3><p>组件在 vue 中是指可复用的 vue 实例，封装了标签样式和 js ，当有重复的标签可复用时可以封装成组件，封装后组件之间作用域各自独立，互不影响，组件又分为全局组件和局部组件</p>
<ul>
<li>全局组件： 在 main.js 中注册，注册后项目全局可用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局注册，注册后其他地方想使用直接用组件名即可</span></span><br><span class="line"><span class="keyword">import</span> 组件对象 <span class="keyword">from</span> <span class="string">&#x27;vue文件路径&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;组件名&quot;</span>, 组件对象)</span><br><span class="line"><span class="comment">// 补充一个全局注册组件的方法,此方法所有全局组件必须带 name , 组件名就是 name</span></span><br><span class="line"><span class="comment">// 在 components/index.js 中默认导出一个对象</span></span><br><span class="line"><span class="comment">// 原始写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PageTools</span> <span class="keyword">from</span> <span class="string">&#x27;./PageTools/index.vue&#x27;</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   <span class="title function_">install</span>(<span class="params">Vue</span>) &#123;</span><br><span class="line">     <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;PageTools&#x27;</span>, <span class="title class_">PageTools</span>)</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// webpack + proxy 打包写法,一次到位,无需重复注册组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">install</span>(<span class="params">Vue</span>) &#123;</span><br><span class="line">      <span class="comment">// 三个参数,分别是文件路径,是否深层次查找, 正则查找 .vue 文件</span></span><br><span class="line">    <span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.vue$/</span>)</span><br><span class="line">    requireComponent.<span class="title function_">keys</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// requireComponent.keys() 返回一个数组,包含目录下所有 .vue 文件的相对路径</span></span><br><span class="line">        <span class="comment">// requireComponent(item).default 返回对应组件对象,所以组件需配置 name </span></span><br><span class="line">      <span class="keyword">const</span> moduleObj = requireComponent(item).<span class="property">default</span></span><br><span class="line">      <span class="title class_">Vue</span>.<span class="title function_">component</span>(moduleObj.<span class="property">name</span>, moduleObj)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部组件： 在组件内部引入，注册其他组件，只在当前组件可用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建组件</span></span><br><span class="line"><span class="comment">// 2. 引入组件	import Pannel from &#x27;./components/Pannel_1&#x27;</span></span><br><span class="line"><span class="comment">// 3. 注册组件  components: &#123;&quot;组件名&quot;: 组件对象&#125;</span></span><br><span class="line"><span class="comment">// 4. 在页面使用组件 &lt;Pannel&gt;&lt;/Pannel&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下每个 vue 文件中的 style 标签会影响其他文件的样式，所以封装组件时给组件 style 标签添加上 scoped 标签，可以使样式只作用于当前组件，不造成样式污染</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt; <span class="comment">// 原理是会自动给标签添加 data-v-hash 值属性, 所有选择器都带</span></span><br></pre></td></tr></table></figure>

<h3 id="9-组件通讯"><a href="#9-组件通讯" class="headerlink" title="9.组件通讯"></a>9.组件通讯</h3><p>每个组件的变量和值都是独立的，当组件之间相互传值时就需要用到组件通讯，父向子传值称之为单向数据流，不可直接修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父向子传值，通过自定义属性名传值，子组件通过 props 接收</span></span><br><span class="line">&lt;<span class="title class_">TodoMain</span> @delFn=<span class="string">&quot;delFn&quot;</span> :list=<span class="string">&quot;showArr&quot;</span>&gt;&lt;/<span class="title class_">TodoMain</span>&gt;</span><br><span class="line"><span class="attr">props</span>: [<span class="string">&quot;list&quot;</span>], <span class="comment">// 简单写法可以写成数组接收</span></span><br><span class="line"><span class="attr">props</span>: &#123;		<span class="comment">// 完整写法,可以限制条件</span></span><br><span class="line">    <span class="attr">tittle</span>: &#123; 	<span class="comment">// 接收的值</span></span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,	 <span class="comment">// 值数据类型</span></span><br><span class="line">      <span class="attr">default</span>: <span class="string">&quot;购物车案例&quot;</span>, <span class="comment">// 不传的时候默认值</span></span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,	<span class="comment">// 设置后为必传值，不传会报错</span></span><br><span class="line">   &#125; &#125;,</span><br><span class="line"><span class="comment">// 子向父传值	通过 this.$emit(&#x27;自定义事件名&#x27;,值) 触发父组件事件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;delFn&#x27;</span>，值）</span><br><span class="line"><span class="attr">metheds</span>:&#123;</span><br><span class="line">    <span class="title function_">delFn</span>(值）&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-组件生命周期"><a href="#10-组件生命周期" class="headerlink" title="10.组件生命周期"></a>10.组件生命周期</h3><p>从 vue 实例创建到销毁的过程称之为 vue 生命周期，有四个阶段八个钩子函数，分别是初始化&#x2F; 挂载&#x2F; 更新&#x2F; 销毁，钩子函数会随着生命周期阶段自动执行，在组件外部加了 <code>keep-alive</code> 后多了两个钩子函数</p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>方法名</strong></th>
<th><strong>方法名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>beforeCreate</td>
<td>created</td>
</tr>
<tr>
<td>挂载</td>
<td>beforeMount</td>
<td>mounted</td>
</tr>
<tr>
<td>更新</td>
<td>beforeUpdate</td>
<td>updated</td>
</tr>
<tr>
<td>销毁</td>
<td>beforeDestroy</td>
<td>destroyed</td>
</tr>
<tr>
<td>缓存</td>
<td>activated</td>
<td>deactivated</td>
</tr>
</tbody></table>
<ol>
<li><p>初始化阶段：</p>
<ul>
<li><p>beforeCreate：初始化事件和生命周期函数</p>
</li>
<li><p>created： 数据和方法在此处可以获取到，但是 dom 还未挂载获取不到，此处一般用来发送 ajax 请求</p>
</li>
</ul>
</li>
<li><p>挂载阶段：</p>
<ul>
<li>beforeMount： 挂载前触发，此处 dom 还未真正挂载</li>
<li>mounted： dom 挂载后触发，此处可以获取真实 dom 和所有的数据方法，一般在此处获取真实 dom</li>
</ul>
</li>
<li><p>更新阶段：</p>
<ul>
<li>beforeUpdate：数据发生改变时触发，此时数据已经更新但 dom 还未更新</li>
<li>updated：数据和 dom 都更新后触发</li>
</ul>
</li>
<li><p>销毁阶段</p>
<ul>
<li>beforeDestroy：销毁实例前触发</li>
<li>destroyed：实例销毁时触发，一般在此处清除定时器、事件</li>
</ul>
</li>
<li><p>缓存阶段：加了缓存后组件不会销毁</p>
<ul>
<li>activated：使用keep-alive的组件激活时触发</li>
<li>deactivated：使用keep-alive 的组件销毁时触发</li>
</ul>
</li>
</ol>
<h3 id="11-axios"><a href="#11-axios" class="headerlink" title="11. axios"></a>11. axios</h3><p>Ajax 是一种前端异步请求后端的技术,基于浏览器的 XMLHttpRequest 方法进行的封装,而 axios 是基于原生 ajax + Promise 技术封装通用于前后端的请求库，常用来在项目中处理请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = axios	<span class="comment">// 在 vue 中挂载到实例上</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span>= 地址	   <span class="comment">// 添加基地址</span></span><br></pre></td></tr></table></figure>

<h3 id="12-自定义指令"><a href="#12-自定义指令" class="headerlink" title="12.自定义指令"></a>12.自定义指令</h3><p>当 vue 内置指令满足不了需求时，或者需对普通 dom 元素进行底层操作时可以使用自定义指令，获取 dom 标签，扩展额外功能</p>
<ul>
<li>全局注册：在 main.js 中进行注册, 项目中任意组件使用只需要 v- 自定义指令名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局指令 - 到处&quot;直接&quot;使用</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;自定义指令名&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>() <span class="comment">// 触发标签的事件方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>局部注册：只在当前组件中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inserted方法 - 指令所在标签, 被插入到网页上触发(一次)</span></span><br><span class="line"><span class="comment">// update方法 - 指令对应数据/标签更新时, 此方法执行</span></span><br><span class="line"> <span class="attr">directives</span>: &#123;</span><br><span class="line">        <span class="attr">focus</span>: &#123;</span><br><span class="line">            <span class="title function_">inserted</span>(<span class="params">el</span>)&#123;	<span class="comment">// 此处的 el 代表自定义指令所对应的当前组件对象</span></span><br><span class="line">                el.<span class="title function_">focus</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-进阶-Api"><a href="#13-进阶-Api" class="headerlink" title="13. 进阶 Api"></a>13. 进阶 Api</h3><h5 id="1-nextTick"><a href="#1-nextTick" class="headerlink" title="1.  $nextTick()"></a>1.  $nextTick()</h5><ul>
<li>在vue中 , DOM 更新是异步的,在更新数据后想获取到最新的 DOM 此时就可以用到this.$nextTick ,此外在 updated 钩子函数中也能获取到更新后的 DOM</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this.$nextTick() 会返回 promise 对象，可以获取到更新数据后的 dom</span></span><br><span class="line"> <span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myP</span>.<span class="property">innerHTML</span>); <span class="comment">// 1</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-refs"><a href="#2-refs" class="headerlink" title="2. $refs"></a>2. $refs</h5><ul>
<li>使用组件时，有时需要调用组件的方法，这时就可以用到 $refs 获取到组件对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;h&quot;</span> ref=<span class="string">&quot;myH&quot;</span>&gt;我是一个h1&lt;/h1&gt;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myH</span>		<span class="comment">// h1 对象</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;h&quot;</span>) <span class="comment">// h1 对象</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">myH</span>.<span class="title function_">fn</span>() <span class="comment">// 调用组件对象的方法，也可以访问组件的数据</span></span><br></pre></td></tr></table></figure>

<h5 id="3-v-model"><a href="#3-v-model" class="headerlink" title="3. v-model"></a>3. v-model</h5><p>v-model 本质就是一个语法糖，向标签的 value 属性赋值，并绑定 input 事件，将收到的最新值赋值给变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本质就是语法糖，绑定变量，绑定 input 事件</span></span><br><span class="line">&lt;<span class="title class_">AddBtn</span> v-model=<span class="string">&quot;count&quot;</span>&gt;&lt;/<span class="title class_">AddBtn</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">AddBtn</span> <span class="attr">:value</span>=<span class="string">&quot;count&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;val =&gt; count = val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">AddBtn</span>&gt;</span></span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, <span class="variable language_">this</span>.<span class="property">value</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="4-动态组件"><a href="#4-动态组件" class="headerlink" title="4. 动态组件"></a>4. 动态组件</h5><p>多个组件使用同一挂载点并动态切换不同的组件，称之为动态组件，通过对组件变量名进行不同赋值达到动态更换组件的目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用动态组件 component 标签，给 is 属性绑定组件变量名，切换变量名值显示不同组件</span></span><br><span class="line">&lt;component :is=<span class="string">&quot;comName&quot;</span>&gt;&lt;/component&gt;</span><br><span class="line"><span class="comment">// data 中定义组件变量名，引入组件注册，切换变量名值为要显示的组件名</span></span><br></pre></td></tr></table></figure>

<h5 id="5-组件缓存"><a href="#5-组件缓存" class="headerlink" title="5. 组件缓存"></a>5. 组件缓存</h5><p>组件切换会导致组件被频繁销毁和重新创建, 性能不高。使用 Vue 内置的 keep-alive 组件, 可以让包裹的组件保存在内存中不被销毁，而是缓存起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keep-alive 可以提高组件性能，包裹的组件不会被销毁和重新创建，还会多了两个钩子函数</span></span><br><span class="line"><span class="comment">// activated 组件激活时触发 deactivated 组件失活时触发</span></span><br><span class="line"><span class="comment">// keep-alive 包含两个属性，exclude 不缓存值对应组件， include 只缓存值对应组件</span></span><br><span class="line"><span class="comment">// 如需使用 exclude/include 组件内需配置 name 值，组件名对应 name 值</span></span><br><span class="line">&lt;keep-alive exclude=<span class="string">&quot;组件名&quot;</span> include=<span class="string">&#x27;组件名&#x27;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<h5 id="6-sync-修饰符"><a href="#6-sync-修饰符" class="headerlink" title="6. .sync 修饰符"></a>6. .sync 修饰符</h5><p>是对父子组件传值的一个语法糖,类似于 v-model ,方便父子之间传值与修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:visible.<span class="property">sync</span>=<span class="string">&quot;dialogVisible&quot;</span> 	<span class="comment">// element dialog 中就有用到</span></span><br><span class="line"><span class="comment">// 父组件给子组件传值,子组件通过 props 接收值, 并通过 emit 绑定修饰符事件,可以直接修改传过来的值</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;visible&#x27;</span>],</span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:visible&#x27;</span>, 新值)</span><br></pre></td></tr></table></figure>

<h3 id="14-插槽"><a href="#14-插槽" class="headerlink" title="14. 插槽"></a>14. 插槽</h3><p>当组件内某一部分的标签和内容不确定或者需要自定义时可以使用到插槽技术，在组件内用 <code>slot</code> 占位，使用组件时传入具体的标签，会替换掉 <code>slot</code> 的默认内容。插槽又分为 具名和作用域插槽</p>
<ul>
<li>具名插槽：当组件内有多处标签需要自定义时，传入的标签可以派发给不同的 <code>slot</code> 位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件内用 slot 占位 配上 name 属性，使用时 template 配合v-slot：name 值传入具体标签</span></span><br><span class="line"><span class="comment">// v-slot 可以简写成 #</span></span><br><span class="line">&lt;slot name=<span class="string">&quot;title&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>作用域插槽：当需要使用到子组件内的变量时 需要用到作用域插槽。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 子组件内通过 slot占位 同时绑定属性和子组件的值 </span></span><br><span class="line"> &lt;slot :row=<span class="string">&quot;defaultObj&quot;</span>&gt;&#123;&#123; defaultObj.<span class="property">name</span> &#125;&#125;&lt;/slot&gt;</span><br><span class="line"><span class="comment">// 2. 使用组件 传入自定义标签,用 template 和 v-slot=&#x27;自定义变量名&#x27;</span></span><br><span class="line"><span class="comment">// 3. scope 变量名自动绑定 slot 上所有属性和值</span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     	// scope: &#123;row: defaultObj&#125; scope.row 就是子组件绑定的变量值</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; scope.row.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="15-路由"><a href="#15-路由" class="headerlink" title="15.路由"></a>15.路由</h3><p>路由是一种映射关系，在 Vue 中路由是路径和组件的映射关系。由于 vue 是单页面应用，所以依赖于路由切换显示不同的页面。vue-router 是官方推荐的路由模块包，引入项目中即可使用</p>
<ul>
<li>SPA：指单页面应用，只有一个 html 文件，不用刷新页面用户体验好。但其缺点就是首次加载慢，不利于 SEO 优化</li>
<li>组件分类： 分为页面组件 <code>src/views\/pages</code> 和复用组件 <code>src/components</code> </li>
<li>使用路由需先配置，后续使用脚手架都配置好了</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 下包 yarn add vue-router</span></span><br><span class="line"><span class="comment">// 2.导入 import VueRouter from &#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// 3.导入组件对象 import My from &#x27;./my.vue‘</span></span><br><span class="line"><span class="comment">// 4.注册路由 Vue.use(VueRouter)</span></span><br><span class="line"><span class="comment">// 5.配置规则 const routes = [&#123;</span></span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/my&#x27;</span>, <span class="attr">component</span>: <span class="title class_">My</span> , <span class="attr">name</span>: <span class="string">&#x27;my&#x27;</span>, </span><br><span class="line">      <span class="attr">chlidren</span>: [</span><br><span class="line">           &#123; 路由规则&#125;</span><br><span class="line">      ]</span><br><span class="line"> &#125;]</span><br><span class="line"><span class="comment">// 5. 创建路由实例对象  const router = new VueRouter(&#123;</span></span><br><span class="line">   routers, </span><br><span class="line">   <span class="attr">mode</span>: <span class="string">&#x27;hash&#x27;</span> <span class="comment">// 路由模式 hash/history</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 6.挂载到 vue 实例上  new Vue(&#123;</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  router,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line"><span class="comment">// 7. 使用 router-view 组件占位, 将来路径匹配后会将指定的组件替换到此处</span></span><br></pre></td></tr></table></figure>

<ul>
<li>路由规则配置</li>
</ul>
<table>
<thead>
<tr>
<th>配置</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>path</td>
<td>匹配路由访问的路径</td>
<td></td>
</tr>
<tr>
<td>component</td>
<td>访问路径所对应的组件对象</td>
<td>可以使用懒加载</td>
</tr>
<tr>
<td>redirect</td>
<td>路由重定向</td>
<td>可以重定向到别的路径</td>
</tr>
<tr>
<td>children</td>
<td>路由的嵌套，子路由</td>
<td>子路由 path 不带 &#x2F;</td>
</tr>
<tr>
<td>*</td>
<td>通配符，当所有的规则都匹配不上时</td>
<td>通常用来匹配 404 页面</td>
</tr>
<tr>
<td>name</td>
<td>路由组件名字</td>
<td></td>
</tr>
<tr>
<td>props</td>
<td>是否开启 props 传参</td>
<td>值为 true 时开启 props 传参</td>
</tr>
</tbody></table>
<ul>
<li><p>路由模式：分为 hash 模式和 history 模式，默认是 hash 模式，在实例化路由对象时修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// history 模式打包上线后需要后台支持, 默认模式是 hash</span></span><br><span class="line"><span class="comment">// hash 模式 url 地址栏后面带 #</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;history&quot;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由守卫：路由有三类钩子函数，最常用的就是前置导航守卫</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局钩子函数，路由在跳转前会执行 beforeEach(to, from, next) =&gt; &#123;&#125;）</span></span><br><span class="line"><span class="comment">// to	要跳转的路由	from	从哪里跳转来的	next	执行 next() 路由才会正常跳转</span></span><br><span class="line"><span class="comment">// 单独路由独享组件	beforeEnter</span></span><br><span class="line"><span class="comment">// 组件内钩子	beforeRouterEnter beforeRouterUpdate beforeRouterLeave</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>路由跳转方式，分为声明式导航(链接跳转)和编程式导航( js 跳转)</p>
<ul>
<li>声明式导航：路由提供了一个全局组件<code> router-link</code> ，最终会渲染成 a 链接 to 属性等价于 href属性(to无需#)，且提供了导航高亮的功能(自带类名)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/find?name=张三&amp;age=18&quot;</span>&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line"><span class="comment">// 携带类名 router-link-active 模糊匹配	router-link-exact- active 精确匹配</span></span><br><span class="line"><span class="comment">// 传参方式为 query 用?分隔 &amp; 符号拼接	或者是 params	直接用 /name/age 表示</span></span><br><span class="line"><span class="comment">// 接收参数 $route.query/$route.params 其中 params 需在路由规则中按顺序加 ：才会生效</span></span><br><span class="line"><span class="comment">// query 参数称为查询参数	 params 参数称为路径参数，使用路径传参时还可以使用 props 接收参数</span></span><br><span class="line"><span class="comment">// 当组件开启了 props 传参时，在组件内直接使用 props 接收参数即可代替 $route.params</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>] === $route.<span class="property">params</span>.<span class="property">name</span>/age</span><br><span class="line"><span class="comment">// path 是路径部分，不包含参数		fullPath 是完整地址，包含参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编程式导航：用 js 来进行路由跳转 <code>$router.push</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $router.push() 路由跳转(有历史记录) $router.replace() 路由替换（无历史记录）      $router.go() 路由前进(正值)/后退(负值)，超过最大值则原地不动。实际开发用		      $router.back() 后退 $router.forword() 前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/my&#x27;</span>,  <span class="comment">// 路由路径</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;my&#x27;</span>,	<span class="comment">// 路由名</span></span><br><span class="line">  <span class="attr">query</span>: &#123;		<span class="comment">// 使用 path 或 name 均可以</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">params</span>: &#123;		<span class="comment">// 使用 path 会忽略 params 的参数</span></span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对应路由接收   $route.params.参数名  / $route.query.参数名  </span></span><br><span class="line"><span class="comment">// 推荐用 path+query 传 $route.query 接或 name + params 传 $route.params 接</span></span><br><span class="line"><span class="comment">// 使用 path + query 传参会在地址栏显示传的参数  name + params 传不会显示参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$route是路由参数对象，包括 ‘path，hash，query，fullPath，matched，name’ 等路由信息参数。</p>
</li>
<li><p>$router是路由实例对象，包括了路由的跳转方法，实例对象等</p>
</li>
<li><p>路由工作原理：用户点击跳转，导致 url 地址栏的 hash 值发生变化，监听 hash 值的变化，触发 <code>window.onhashchange</code> 事件，使用动态组件将 hash 值对应的组件渲染到页面中。</p>
</li>
</ul>
<h3 id="16-Vuex"><a href="#16-Vuex" class="headerlink" title="16. Vuex"></a>16. Vuex</h3><p>Vuex 是官方推荐的状态管理工具，采用集中式存储来管理应用所有组件的状态，解决多组件之间的数据通讯问题，简单来说就是独立于组件外的管理公共数据的工具。</p>
<p>总体来说 Vuex 分为五个部分，其中 state 和 mutations 是比较重要的</p>
<h5 id="1-state"><a href="#1-state" class="headerlink" title="1.state"></a>1.state</h5><ul>
<li><h5 id="用来定义和存放公共数据，是一个对象"><a href="#用来定义和存放公共数据，是一个对象" class="headerlink" title="用来定义和存放公共数据，是一个对象"></a>用来定义和存放公共数据，是一个对象</h5></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数据，是一个对象，也可以写成一个函数，数据是响应式的，且不能直接修改数据</span></span><br><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line">   属性名： 属性值 </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">state：()=&gt; (&#123; <span class="attr">list</span>: []&#125;)</span><br><span class="line"><span class="comment">// 组件中用 this.$store.state 来访问</span></span><br></pre></td></tr></table></figure>

<h5 id="2-mutations"><a href="#2-mutations" class="headerlink" title="2.mutations"></a>2.mutations</h5><ul>
<li><h5 id="用来处理-state-中定义的数据，处理同步任务，处理异步任务不报错但是追踪不到数据的变化，且严格模式下会报错"><a href="#用来处理-state-中定义的数据，处理同步任务，处理异步任务不报错但是追踪不到数据的变化，且严格模式下会报错" class="headerlink" title="用来处理 state 中定义的数据，处理同步任务，处理异步任务不报错但是追踪不到数据的变化，且严格模式下会报错"></a>用来处理 state 中定义的数据，处理同步任务，处理异步任务不报错但是追踪不到数据的变化，且严格模式下会报错</h5></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation 是一个对象，每一项都是函数，有两个形参，第一个形参永远是 state ，第二个是载荷，也就是传递的参数，可选参数，如有多个参数需要传递可以写成对象</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    函数名(state, payload) &#123;</span><br><span class="line">      state.<span class="property">list</span> = payload;</span><br><span class="line"> &#125;&#125;</span><br><span class="line"><span class="comment">// 组件中用 this.$store.commit(&#x27;mutation名&#x27;, 载荷) 来访问</span></span><br></pre></td></tr></table></figure>

<h5 id="3-actions"><a href="#3-actions" class="headerlink" title="3.actions"></a>3.actions</h5><ul>
<li><h5 id="用来处理-Vuex-中的异步任务，通过调用-mutations-中的方法来间接修改-state-数据"><a href="#用来处理-Vuex-中的异步任务，通过调用-mutations-中的方法来间接修改-state-数据" class="headerlink" title="用来处理 Vuex 中的异步任务，通过调用 mutations 中的方法来间接修改 state 数据"></a>用来处理 Vuex 中的异步任务，通过调用 mutations 中的方法来间接修改 state 数据</h5></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">actions:&#123;</span><br><span class="line">	// 第一个参数为 context 自动传入表示 store 实例，第二个参数为载荷，传入的参数</span><br><span class="line">	函数名(context，载荷)&#123;</span><br><span class="line">		函数体</span><br><span class="line">		 context.commit(&#x27;mutation名&#x27;, 载荷)</span><br><span class="line">	&#125;&#125;</span><br><span class="line">// 组件中用 this.$store.dispatch(&#x27;actions 名&#x27;, 载荷) 来访问</span><br></pre></td></tr></table></figure>

<h5 id="4-getters"><a href="#4-getters" class="headerlink" title="4.getters"></a>4.getters</h5><ul>
<li><h5 id="类似于组件中的计算属性。定义数据，对-state-中的数据进行计算得到新数据"><a href="#类似于组件中的计算属性。定义数据，对-state-中的数据进行计算得到新数据" class="headerlink" title="类似于组件中的计算属性。定义数据，对 state 中的数据进行计算得到新数据"></a>类似于组件中的计算属性。定义数据，对 state 中的数据进行计算得到新数据</h5></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能获取结果，没有 set 方法修改 state 数据</span></span><br><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">   <span class="comment">// 第一个参数永远是 state ，可以进行解构</span></span><br><span class="line">  <span class="title function_">isShow</span>(<span class="params">&#123; list &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">every</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">goods_state</span> === <span class="literal">true</span>);</span><br><span class="line"> &#125;&#125;</span><br><span class="line"><span class="comment">// 组件中用 this.$store.getters 来访问</span></span><br></pre></td></tr></table></figure>

<h5 id="5-modules"><a href="#5-modules" class="headerlink" title="5.modules"></a>5.modules</h5><ul>
<li><h5 id="拆分模块，将不同的场景按模块区分开，方便开发和维护"><a href="#拆分模块，将不同的场景按模块区分开，方便开发和维护" class="headerlink" title="拆分模块，将不同的场景按模块区分开，方便开发和维护"></a>拆分模块，将不同的场景按模块区分开，方便开发和维护</h5></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用需先在子模块中开设命名空间	namespaced: true</span></span><br><span class="line"><span class="comment">// 之后在主模块中导入子模块并注册 modules:&#123; 注册模块名：模块对象 &#125;</span></span><br><span class="line"><span class="comment">// 使用子模块的数据和方法 $store.state.模块名.属性名	$store.getters.模块名.属性名</span></span><br><span class="line"><span class="comment">// $store.commit(&#x27;模块名/函数名&#x27;, 载荷) $store.dispatch(&#x27;模块名/函数名&#x27;, 载荷)</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">   注册模块名：模块对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="6-辅助函数"><a href="#6-辅助函数" class="headerlink" title="6.辅助函数"></a>6.辅助函数</h5><ul>
<li><h5 id="是-Vuex-定义好的工具函数，可以优化访问-Vuex-中的属性和方法"><a href="#是-Vuex-定义好的工具函数，可以优化访问-Vuex-中的属性和方法" class="headerlink" title="是 Vuex 定义好的工具函数，可以优化访问 Vuex 中的属性和方法"></a>是 Vuex 定义好的工具函数，可以优化访问 Vuex 中的属性和方法</h5></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入辅助函数 导入后可以直接使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations, mapActions, mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 优化 state 和 getters ，在组件 computed 属性中展开</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(<span class="string">&#x27;模块名&#x27;</span>, [<span class="string">&#x27;属性名&#x27;</span>] ), </span><br><span class="line">  ...<span class="title function_">mapGetters</span>(<span class="string">&#x27;模块名&#x27;</span>,[<span class="string">&#x27;属性名&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化 mutations 和 actions ，在组件 methods 属性中展开</span></span><br><span class="line"><span class="attr">methods</span>: &#123; </span><br><span class="line">  ...<span class="title function_">mapMutations</span>(<span class="string">&#x27;模块名&#x27;</span>, [<span class="string">&#x27;xxx&#x27;</span>]), </span><br><span class="line">  ...<span class="title function_">mapActions</span>(<span class="string">&#x27;模块名&#x27;</span>,&#123;<span class="string">&#x27;新名字&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-常见-UI-组件库"><a href="#17-常见-UI-组件库" class="headerlink" title="17.常见 UI 组件库"></a>17.常见 UI 组件库</h3><p>pc 端常用的 element-ui、ant、iview 等，移动端常用的 vant、didi、jd 等，小程序常用的 uniapp，配置及文档详见官网。</p>
<h3 id="18-过滤器"><a href="#18-过滤器" class="headerlink" title="18.过滤器"></a>18.过滤器</h3><blockquote>
<p>这个功能在 Vue3 中被取消了</p>
</blockquote>
<p>主要用来对插值表达式和 v-bind 的值进行处理，是一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局过滤器，在 main.js 中定义,第一个参数是过滤器名，第二个参数是回调函数，形参就是原内容</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;过滤器名&#x27;</span>，<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">	<span class="comment">// 此处的 val 就是过滤前的数据，进行一系列处理后 return 返回</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 局部过滤器，在组件内部定义，参数是一样，必须有返回值</span></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">	过滤器名(形参)&#123;</span><br><span class="line">		处理函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用都是一样的，在数据后面用 | 隔开，后面写过滤器名</span></span><br><span class="line">&#123;&#123; msg | 过滤器名 &#125;&#125; 或 &lt;div :list=<span class="string">&#x27;list | 过滤器名&#x27;</span>&gt; 内容&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="19-样式穿透"><a href="#19-样式穿透" class="headerlink" title="19.样式穿透"></a>19.样式穿透</h3><p>当组件 style 标签添加了 scoped 属性后，组件的每一个标签都会在原有的类名上自动添加属性选择器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;</span><br><span class="line"><span class="comment">// 添加 scoped 后标签名变成了 p[data-v-sd5dsa] 这种原有选择器和属性选择器的结合</span></span><br><span class="line"><span class="comment">// 当组件内部使用了子组件时，直接修改子组件样式不会生效，因为子组件并没有添加上属性选择器</span></span><br><span class="line"><span class="comment">// 在子组件类名前添加穿透命令，即可将子组件类名变成 [data-v-sd5dsa] p 这种后代选择器，样式就会生效，在第三方的 UI 组件库中使用的较多</span></span><br><span class="line"><span class="comment">// less 中用 /deep/ 设置	scss 中用 ::v-deep 设置		css 中用 &gt;&gt;&gt; 设置</span></span><br><span class="line"> p &#123;</span><br><span class="line">  <span class="attr">padding</span>: 46px <span class="number">0</span> 50px <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="20-EventBus-组件传值"><a href="#20-EventBus-组件传值" class="headerlink" title="20.EventBus 组件传值"></a>20.EventBus 组件传值</h3><blockquote>
<p>这个功能在 Vue3 中被取消了</p>
</blockquote>
<p>任意两个组件之间(兄弟组件或无任何关系的组件之间)传值可以使用 <code>EventBus</code>和 <code>Vuex</code> 来实现</p>
<p>有两种方式来创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建 EventBus 的 js 文件，导出 vue 实例对象</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">// 导出空白vue对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br><span class="line"><span class="comment">// 2.在 main.js 中原型上添加 EventBus</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"><span class="comment">// 创建后需要传值时导入 EventBus ，当 A 向 B 传值时，A 组件中声明方法触发 EventBus 事件</span></span><br><span class="line"> <span class="title class_">EventBus</span>.$emit(<span class="string">&quot;自定义事件名&quot;</span>, 实参/载荷);</span><br><span class="line"><span class="comment">// B 组件在 created 接收值，使用完后最好对 EventBus 进行销毁，防止全局污染</span></span><br><span class="line"> <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    bus.$on(<span class="string">&quot;自定义事件名&quot;</span>, <span class="function">(<span class="params">形参</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="21-依赖注入"><a href="#21-依赖注入" class="headerlink" title="21. 依赖注入"></a>21. 依赖注入</h3><p>通常使用 props 进行父子传值,但当组件嵌套较深时数据的传递会非常繁琐,官方提供了 <code>provide</code> 和 <code>inject</code> 方法方便祖先组件向其所有子孙后代传递数据,不论组件层级有多深均可实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 和 data methods 等平级,可以是一个对象或返回一个对象的函数</span></span><br><span class="line"> <span class="attr">provide</span>: &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"> <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 子孙后代组件接收传递的数据,使用 inject 接收, 可以是一个字符串数组,也可以是一个对象</span></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>],</span><br><span class="line"><span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="comment">// from 表示数据的来源组件</span></span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;foo&#x27;</span> <span class="comment">// 与 prop 的默认值类似, 可以是一个默认值或者工厂函数</span></span><br><span class="line">      <span class="attr">default</span>: <span class="function">() =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://metabo6.github.io">随时奉陪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://metabo6.github.io/posts/8c5fb31e.html">https://metabo6.github.io/posts/8c5fb31e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://metabo6.github.io" target="_blank">随时奉陪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue2/">Vue2</a></div><div class="post_share"><div class="social-share" data-image="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/vue2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f2e91a06.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/ts.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TypeScript 总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/ea4ca316.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/webapi.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WEB API 总结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly/index.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">随时奉陪</div><div class="author-info__description">向往自由，追求自由，找寻自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/metabo6"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Vue2 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-webpack"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#webpack-%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%EF%BC%9A-%E5%88%86%E4%B8%BA%E5%85%A5%E5%8F%A3%EF%BC%8C%E5%87%BA%E5%8F%A3%EF%BC%8C%E6%89%93%E5%8C%85%E6%A8%A1%E5%BC%8F%EF%BC%8Cloader-%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8Cplugins-%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.1.0.0.1.</span> <span class="toc-text">webpack 配置修改： 分为入口，出口，打包模式，loader 加载器，plugins 插件配置</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.脚手架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Vue-%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%8C%87%E4%BB%A4%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. Vue 概念及指令修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vue%E6%98%AF%E4%B8%80%E4%B8%AAJavaScript%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%B0%B1%E6%98%AF%E6%8C%89%E9%9C%80%E9%80%90%E6%B8%90%E9%9B%86%E6%88%90%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%BA%93%E6%98%AF%E6%96%B9%E6%B3%95%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%8C%E8%80%8C%E6%A1%86%E6%9E%B6%E6%98%AF%E4%B8%80%E5%A5%97%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E8%A7%84%E5%88%99%E7%9A%84%E8%AF%AD%E6%B3%95%E3%80%82%E5%AD%A6%E4%B9%A0-Vue-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E5%BC%80%E5%8F%91%E6%9B%B4%E5%BF%AB%E9%80%9F%EF%BC%8C%E6%9B%B4%E9%AB%98%E6%95%88%EF%BC%8C%E4%B8%94%E5%B8%82%E5%9C%BA%E5%8D%A0%E6%9C%89%E7%8E%87%E9%AB%98%E3%80%82"><span class="toc-number">1.0.3.0.1.</span> <span class="toc-text">Vue是一个JavaScript渐进式框架，渐进式就是按需逐渐集成功能，库是方法的集合，而框架是一套拥有自己规则的语法。学习 Vue 可以使开发更快速，更高效，且市场占有率高。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-%E6%8C%87%E4%BB%A4%EF%BC%8C%E5%AE%98%E6%96%B9%E5%B0%81%E8%A3%85%E5%A5%BD%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.3.0.2.</span> <span class="toc-text">vue 指令，官方封装好的指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.0.3.0.3.</span> <span class="toc-text">修饰符：事件修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E5%9C%A8%E6%A0%87%E7%AD%BE%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%8C%85%E8%A3%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">1.0.3.0.4.</span> <span class="toc-text">插值表达式：在标签里面可以使用双大括号包裹表达式，转换成表达式结果展示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVVC-%EF%BC%9A%E6%98%AF%E7%A7%8D%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8F%8C%E5%90%91%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%87%8F%E5%B0%91%E6%93%8D%E4%BD%9C-dom-%EF%BC%8C%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87"><span class="toc-number">1.0.3.0.5.</span> <span class="toc-text">MVVC ：是种软件架构模式，通过数据双向绑定让数据自动的双向同步，减少操作 dom ，提高开发效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVC-%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%84-%E6%98%AFmodel%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-view%E8%A7%86%E5%9B%BE-Controller%E6%8E%A7%E5%88%B6%E5%99%A8-%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%99%E5%B1%82%E9%87%8C%E7%BC%96%E5%86%99js%E4%BB%A3%E7%A0%81-%E6%9D%A5%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A7%86%E5%9B%BE%E5%85%B3%E8%81%94"><span class="toc-number">1.0.3.0.6.</span> <span class="toc-text">MVC: 也是一种设计模式, 组织代码的结构, 是model数据模型, view视图, Controller控制器, 在控制器这层里编写js代码, 来控制数据和视图关联</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-v-for"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. v-for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81-class-%E5%92%8C%E5%8A%A8%E6%80%81-style"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 动态 class 和动态 style</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 计算属性 computed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BE%A6%E5%90%AC%E5%99%A8-watch"><span class="toc-number">1.0.7.</span> <span class="toc-text">7.侦听器 watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">8.组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="toc-number">1.0.9.</span> <span class="toc-text">9.组件通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">10.组件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-axios"><span class="toc-number">1.0.11.</span> <span class="toc-text">11. axios</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.12.</span> <span class="toc-text">12.自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%BF%9B%E9%98%B6-Api"><span class="toc-number">1.0.13.</span> <span class="toc-text">13. 进阶 Api</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-nextTick"><span class="toc-number">1.0.13.0.1.</span> <span class="toc-text">1.  $nextTick()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-refs"><span class="toc-number">1.0.13.0.2.</span> <span class="toc-text">2. $refs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-v-model"><span class="toc-number">1.0.13.0.3.</span> <span class="toc-text">3. v-model</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.13.0.4.</span> <span class="toc-text">4. 动态组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.13.0.5.</span> <span class="toc-text">5. 组件缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.0.13.0.6.</span> <span class="toc-text">6. .sync 修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%8F%92%E6%A7%BD"><span class="toc-number">1.0.14.</span> <span class="toc-text">14. 插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E8%B7%AF%E7%94%B1"><span class="toc-number">1.0.15.</span> <span class="toc-text">15.路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Vuex"><span class="toc-number">1.0.16.</span> <span class="toc-text">16. Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-state"><span class="toc-number">1.0.16.0.1.</span> <span class="toc-text">1.state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AD%98%E6%94%BE%E5%85%AC%E5%85%B1%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.16.0.2.</span> <span class="toc-text">用来定义和存放公共数据，是一个对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-mutations"><span class="toc-number">1.0.16.0.3.</span> <span class="toc-text">2.mutations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E5%A4%84%E7%90%86-state-%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A4%84%E7%90%86%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%8A%A5%E9%94%99%E4%BD%86%E6%98%AF%E8%BF%BD%E8%B8%AA%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E4%B8%94%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">1.0.16.0.4.</span> <span class="toc-text">用来处理 state 中定义的数据，处理同步任务，处理异步任务不报错但是追踪不到数据的变化，且严格模式下会报错</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-actions"><span class="toc-number">1.0.16.0.5.</span> <span class="toc-text">3.actions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E5%A4%84%E7%90%86-Vuex-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%8C%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8-mutations-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E9%97%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-state-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.16.0.6.</span> <span class="toc-text">用来处理 Vuex 中的异步任务，通过调用 mutations 中的方法来间接修改 state 数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-getters"><span class="toc-number">1.0.16.0.7.</span> <span class="toc-text">4.getters</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E4%BA%8E%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E3%80%82%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AF%B9-state-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%BE%97%E5%88%B0%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.16.0.8.</span> <span class="toc-text">类似于组件中的计算属性。定义数据，对 state 中的数据进行计算得到新数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-modules"><span class="toc-number">1.0.16.0.9.</span> <span class="toc-text">5.modules</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%B0%86%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%BA%E6%99%AF%E6%8C%89%E6%A8%A1%E5%9D%97%E5%8C%BA%E5%88%86%E5%BC%80%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%BC%80%E5%8F%91%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.0.16.0.10.</span> <span class="toc-text">拆分模块，将不同的场景按模块区分开，方便开发和维护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.16.0.11.</span> <span class="toc-text">6.辅助函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF-Vuex-%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E8%AE%BF%E9%97%AE-Vuex-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.16.0.12.</span> <span class="toc-text">是 Vuex 定义好的工具函数，可以优化访问 Vuex 中的属性和方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%B8%B8%E8%A7%81-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-number">1.0.17.</span> <span class="toc-text">17.常见 UI 组件库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.0.18.</span> <span class="toc-text">18.过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F"><span class="toc-number">1.0.19.</span> <span class="toc-text">19.样式穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-EventBus-%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="toc-number">1.0.20.</span> <span class="toc-text">20.EventBus 组件传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.0.21.</span> <span class="toc-text">21. 依赖注入</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a5ae354f.html" title="数组、字符串常用方法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/js.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组、字符串常用方法"/></a><div class="content"><a class="title" href="/posts/a5ae354f.html" title="数组、字符串常用方法">数组、字符串常用方法</a><time datetime="2022-11-24T02:24:11.000Z" title="发表于 2022-11-24 10:24:11">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b0de96e1.html" title="CSS 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/css.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS 总结"/></a><div class="content"><a class="title" href="/posts/b0de96e1.html" title="CSS 总结">CSS 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f1991798.html" title="Git 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/git.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 总结"/></a><div class="content"><a class="title" href="/posts/f1991798.html" title="Git 总结">Git 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50b39724.html" title="HTML 总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/HTML.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML 总结"/></a><div class="content"><a class="title" href="/posts/50b39724.html" title="HTML 总结">HTML 总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/588ad959.html" title="JS 基础总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../../../img/React%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93/js.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS 基础总结"/></a><div class="content"><a class="title" href="/posts/588ad959.html" title="JS 基础总结">JS 基础总结</a><time datetime="2022-11-24T02:22:36.000Z" title="发表于 2022-11-24 10:22:36">2022-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 随时奉陪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>